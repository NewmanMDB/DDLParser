<html>
<head>
  <style type="text/css">
    h1 { font-size: 12pt; font-weight: bold; }
    h2 { font-size: 12pt; font-weight: bold; }
    h3 { font-size: 12pt; font-weight: bold; }
    body { font-size: 12pt; }
    code { font-size: 10pt; }
    p { margin-left:2em; }
    pre { margin-left: 2.5em; }
    ul { margin-left: 0.5em; }
    td { font-size: 12pt; }
    th { font-size: 12pt; font-weight: bold; }
  </style>
  <meta name="generator" content="C++2HTML by Jasper Bedaux" />
  <style type="text/css">
    .comment { color: #999999; font-style: italic; }
    .pre { color: #000099; }
    .string { color: #009900; }
    .char { color: #009900; }
    .float { color: #996600; }
    .int { color: #999900; }
    .bool { color: #000000; font-weight: bold; }
    .type { color: #FF6633; }
    .flow { color: #FF0000; }
    .keyword { color: #990000; }
    .operator { color: #663300; font-weight: bold; }
  </style>
</head>
<body>
<hr/><h1>DDL Specification</h1>

<p>DDL files can contain three constructs: selects, bitfields and structures. All constructs must have a name, and they can have an author, a description and a label assigned to them. These fields can be used by tools when rendering the constructs as UI elements.</p>

<p>There is a annotated DDL grammar at the end of this document for further reference.</p>

<h2>Selects</h2>

<p>A select is just a list of options much like an C enum. They represent exclusive values, like a drop-down where just one value can be selected. But unlike C enums, numeric values cannot be assigned to select fields; their values are just the hash of their names. This way new fields can be added without constraints while maintaining compatibility with cold that uses the select.</p>

<p>Each select item can have an author, a description and a label.</p>

<h3>Example</h3>

<code><pre><span class="keyword">select</span> Weapon<span class="operator">,</span><span class="keyword"> author</span><span class="operator">(</span><span class="string"> "Andre de Leiradella"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword"> description</span><span class="operator">(</span><span class="string"> "Weapons available to the player"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword"> label</span><span class="operator">(</span><span class="string"> "Weapon"</span><span class="operator"> )</span><span class="operator">
{</span>
  kFist<span class="operator">,</span><span class="keyword">           description</span><span class="operator">(</span><span class="string"> "Bare hands"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword">               label</span><span class="operator">(</span><span class="string"> "Fist"</span><span class="operator"> )</span><span class="operator">;</span>
  kChainsaw<span class="operator">,</span><span class="keyword">       description</span><span class="operator">(</span><span class="string"> "A la Chainsaw Massacre"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword">   label</span><span class="operator">(</span><span class="string"> "Chainsaw"</span><span class="operator"> )</span><span class="operator">;</span>
  kPistol<span class="operator">,</span><span class="keyword">         description</span><span class="operator">(</span><span class="string"> "Simple pistol"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword">            label</span><span class="operator">(</span><span class="string"> "Pistol"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword"> default</span><span class="operator">;</span>
  kShotgun<span class="operator">,</span><span class="keyword">        description</span><span class="operator">(</span><span class="string"> "A single-barrel shotgun"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword">  label</span><span class="operator">(</span><span class="string"> "Shotgun"</span><span class="operator"> )</span><span class="operator">;</span>
  kChaingun<span class="operator">,</span><span class="keyword">       description</span><span class="operator">(</span><span class="string"> "A machine gun"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword">            label</span><span class="operator">(</span><span class="string"> "Chaingun"</span><span class="operator"> )</span><span class="operator">;</span>
  kRocketLauncher<span class="operator">,</span><span class="keyword"> description</span><span class="operator">(</span><span class="string"> "Portable rocket launcher"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword"> label</span><span class="operator">(</span><span class="string"> "Rocket launcher"</span><span class="operator"> )</span><span class="operator">;</span>
  kPlasmaGun<span class="operator">,</span><span class="keyword">      description</span><span class="operator">(</span><span class="string"> "Plasma gun"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword">               label</span><span class="operator">(</span><span class="string"> "Plasma gun"</span><span class="operator"> )</span><span class="operator">;</span>
  kBFG9000<span class="operator">,</span><span class="keyword">        description</span><span class="operator">(</span><span class="string"> "*The* BFG 9000"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword">           label</span><span class="operator">(</span><span class="string"> "BFG 9000"</span><span class="operator"> )</span><span class="operator">;</span><span class="operator">
}</span></pre></code>

<p>An item can be marked as default (see item <code>kPistol</code>) and it will be the item used in fields declared with the select type that don't have an explicit value to override the default.</p>

<h2>Bitfields</h2>

<p>Bitfields represent a set of related flags. Their flags can be or'ed to form the value of another flag. Bitfields should be used where more than one value can be selected, like a checkbox group.</p>

<p>As with select items, each bitfield flag can have an author, a description and a label.</p>

<h3>Example</h3>

<code><pre><span class="keyword">bitfield</span> Powerup<span class="operator">,</span><span class="keyword"> author</span><span class="operator">(</span><span class="string"> "Andre de Leiradella"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword"> description</span><span class="operator">(</span><span class="string"> "Powerup pickups"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword"> label</span><span class="operator">(</span><span class="string"> "Powerup"</span><span class="operator"> )</span><span class="operator">
{</span>
  kNone<span class="operator">,</span><span class="keyword">                description</span><span class="operator">(</span><span class="string"> "Help me!"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword"> empty</span><span class="operator">;</span>
  kRadiationSuit<span class="operator">,</span><span class="keyword">       description</span><span class="operator">(</span><span class="string"> "Makes the player immune to radiation for a limited time"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword">             label</span><span class="operator">(</span><span class="string"> "Radiation suit"</span><span class="operator"> )</span><span class="operator">;</span>
  kPartialInvisibility<span class="operator">,</span><span class="keyword"> description</span><span class="operator">(</span><span class="string"> "Makes the player almost invisible to enemies for a limited time"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword">     label</span><span class="operator">(</span><span class="string"> "Partial invisibility"</span><span class="operator"> )</span><span class="operator">;</span>
  kInvulnerability<span class="operator">,</span><span class="keyword">     description</span><span class="operator">(</span><span class="string"> "Makes the player invulnerable for a limited time"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword">                    label</span><span class="operator">(</span><span class="string"> "Invulnerability"</span><span class="operator"> )</span><span class="operator">;</span>
  kComputerMap<span class="operator">,</span><span class="keyword">         description</span><span class="operator">(</span><span class="string"> "Gives the complete map of the level to the player"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword">                   label</span><span class="operator">(</span><span class="string"> "Computer map"</span><span class="operator"> )</span><span class="operator">;</span>
  kLightVisor<span class="operator">,</span><span class="keyword">          description</span><span class="operator">(</span><span class="string"> "Allows the player to see in the dark for a limited time"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword">             label</span><span class="operator">(</span><span class="string"> "Light visor"</span><span class="operator"> )</span><span class="operator">;</span>
  kBerserk<span class="operator">,</span><span class="keyword">             description</span><span class="operator">(</span><span class="string"> "Gives the player the ability to quickly kill enemies with his fists"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword"> label</span><span class="operator">(</span><span class="string"> "Berserk"</span><span class="operator"> )</span><span class="operator">;</span>
  kAll<span class="operator">,</span><span class="keyword">                 value</span><span class="operator">(</span> kRadiationSuit<span class="operator"> |</span> kPartialInvisibility<span class="operator"> |</span> kInvulnerability<span class="operator"> |</span> kComputerMap<span class="operator"> |</span> kLightVisor<span class="operator"> |</span> kBerserk<span class="operator"> )</span><span class="operator">;</span><span class="operator">
}</span></pre></code>

<p>Flags without a value will get an unique bit index that can be queried at runtime. Flags can be marked as default. If there isn't a default flag in the bitfield the empty flag will be used, or the first declared flag will be used if there isn't an empty flag. To get a zeroed flag, tag it with <code>empty</code> like the <code>kNone</code> flag above.</p>

<h2>Structures</h2>

<p>While selects and bitfields only define custom types and take no memory, structures are aggregates of fields which actually take up memory to hold their fields' values.</p>

<p>Structure fields can be of the following types:</p>

<ul>
<li><code>u8</code> (or <code>uint8_t</code>)</li>
<li><code>u16</code> (or <code>uint16_t</code>)</li>
<li><code>u32</code> (or <code>uint32_t</code>)</li>
<li><code>u64</code> (or <code>uint64_t</code>)</li>
<li><code>i8</code> (or <code>int8_t</code>)</li>
<li><code>i16</code> (or <code>int16_t</code>)</li>
<li><code>i32</code> (or <code>int32_t</code>)</li>
<li><code>i64</code> (or <code>int64_t</code>)</li>
<li><code>f32</code> (or <code>float</code>)</li>
<li><code>f64</code> (or <code>double</code>)</li>
<li><code>boolean</code></li>
<li><code>string</code></li>
<li><code>file</code></li>
<li><code>tuid</code></li>
<li><code>json</code></li>
<li>Any previously declared select, bitfield or structure</li>
</ul>

<p>Fields can also be arrays of any of these types by just adding <code>[]</code> right after the type name. These arrays cannot take default values, and can grow as needed at runtime. Adding a <code>[ x ]</code>, where <code>x</code> is an integer expression, makes the array fixed and up to <code>x</code> default values can be specified for the field. Just like select items and bitfield flags, structure fields can have an author, a description and a label.</p>

<p>To inform the default value of a field, use the <code>value</code> keyword and write any expression inside the parenthesis. The expression must evaluate to a value which fits in the data type of the field.</p>

<h3>Examples</h3>

<code><pre><span class="keyword">struct</span> Position<span class="operator">
{</span>
  f32 m_X<span class="operator">,</span><span class="keyword">     value</span><span class="operator">(</span><span class="int"> 0</span><span class="operator"> )</span><span class="operator">;</span>
  f32 m_Y<span class="operator">,</span><span class="keyword">     value</span><span class="operator">(</span><span class="int"> 0</span><span class="operator"> )</span><span class="operator">;</span>
  f32 m_Angle<span class="operator">,</span><span class="keyword"> value</span><span class="operator">(</span><span class="int"> 0</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword"> description</span><span class="operator">(</span><span class="string">"The direction the player is looking at (degrees)"</span><span class="operator">)</span><span class="operator">;</span><span class="operator">
}</span><span class="keyword">
struct</span> Mariner<span class="operator">,</span><span class="keyword"> author</span><span class="operator">(</span><span class="string"> "Andre de Leiradella"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword"> description</span><span class="operator">(</span><span class="string"> "The player character"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword"> label</span><span class="operator">(</span><span class="string"> "Player"</span><span class="operator"> )</span><span class="operator">
{</span>
  u32        m_Health<span class="operator">,</span><span class="keyword">     value</span><span class="operator">(</span><span class="int"> 100</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword">                              description</span><span class="operator">(</span><span class="string"> "The player's health"</span><span class="operator"> )</span><span class="operator">;</span>
  Weapon     m_Weapon<span class="operator">,</span><span class="keyword">     value</span><span class="operator">(</span> kPistol<span class="operator"> )</span><span class="operator">,</span><span class="keyword">                          description</span><span class="operator">(</span><span class="string"> "The player's current weapon"</span><span class="operator"> )</span><span class="operator">;</span>
  Powerup    m_Powerup<span class="operator">,</span><span class="keyword">    value</span><span class="operator">(</span> kBerserk<span class="operator"> )</span><span class="operator">,</span><span class="keyword">                         description</span><span class="operator">(</span><span class="string"> "The player's powerups"</span><span class="operator"> )</span><span class="operator">;</span>
  i32<span class="operator">[</span><span class="int"> 8</span><span class="operator"> ]</span>   m_Ammunition<span class="operator">,</span><span class="keyword"> value</span><span class="operator">(</span><span class="operator"> {</span><span class="int"> 0</span><span class="operator">,</span><span class="int"> 0</span><span class="operator">,</span><span class="int"> 20</span><span class="operator">,</span><span class="operator"> -</span><span class="int">1</span><span class="operator">,</span><span class="operator"> -</span><span class="int">1</span><span class="operator">,</span><span class="operator"> -</span><span class="int">1</span><span class="operator">,</span><span class="operator"> -</span><span class="int">1</span><span class="operator">,</span><span class="operator"> -</span><span class="int">1</span><span class="operator"> }</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword"> description</span><span class="operator">(</span><span class="string"> "The ammunition of each weapon, -1 means the player doesn't have it"</span><span class="operator"> )</span><span class="operator">;</span>
  string     m_Name<span class="operator">,</span><span class="keyword">       value</span><span class="operator">(</span><span class="string"> "Mariner"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword">                        description</span><span class="operator">(</span><span class="string"> "The player's name for multiplayer sessions"</span><span class="operator"> )</span><span class="operator">;</span>
  Position   m_Position<span class="operator">,</span><span class="keyword">   value</span><span class="operator">(</span><span class="operator"> {</span> m_X<span class="operator"> =</span><span class="int"> 100</span><span class="operator">,</span> m_Y<span class="operator"> =</span><span class="int"> 120</span><span class="operator"> }</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword">         description</span><span class="operator">(</span><span class="string"> "The player's position"</span><span class="operator"> )</span><span class="operator">;</span>
  Position<span class="operator">[</span><span class="operator">]</span> m_Deaths<span class="operator">,</span><span class="keyword">                                                description</span><span class="operator">(</span><span class="string"> "Places the player has died in"</span><span class="operator"> )</span><span class="operator">;</span><span class="operator">
}</span></pre></code>

<p>Array values must be written inside braces with commas separating each expression. Values of structured fields, like <code>m_Position</code> above, must also appear inside braces. It's not mandatory that all fields are present in the value.</p>

<hr/><h1>Expressions</h1>

<p>DDL expressions are very similar to C expressions, and care has been taken to implement the same operators with the same precedence order. The operators, in decreasing order of precedence, are:</p>

<ul>
<li><code>?</code> (ternary operator)</li>
<li><code>||</code> (logic or)</li>
<li><code>&&</code> (logic and)</li>
<li><code>|</code> (arithmetic or)</li>
<li><code>^</code> (arithmetic xor)</li>
<li><code>&</code> (arithmetic and)</li>
<li><code>==</code> and <code>!=</code> (equality)</li>
<li><code><</code>, <code><=</code>, <code>></code> and <code>>=</code> (comparison)</li>
<li><code><<</code> and <code>>></code> (shift)</li>
<li><code>+</code> and <code>-</code> (add and subtract)</li>
<li><code>*</code>, <code>/</code> and <code>%</code> (multiply, divide and modulus)</li>
<li><code>+</code>, <code>-</code>, <code>~</code> and <code>!</code> (unary positive, negative, complement and logic not)</li>
</ul>

<p>Terminals can be binary, octal, decimal and hexadecimal integer constants, floating point constants, string literals, the <code>true</code> and <code>false</code> constants, <code>pi</code>, the natural number <code>e</code>, and expressions between parenthesis.</p>

<p>Binary constants are written similarly to hexadecimal constants but using the <code>0b</code> prefix instead of <code>0x</code>. String literals are specified inside single or double quotes, and any occurrence of <code>%xx</code> in the string is substituted by the character with hexadecimal value <code>xx</code>.</p>

<p>The constants <code>true</code> and <code>false</code> evaluates to the integers 1 and 0 respectively.</p>

<hr/><h1>Comments</h1>

<p>DDL files can have C and C++ style comments:</p>

<ul>
<li><code>/* this is a comment */</code></li>
<li><code>// this is a comment that ends at the end of the line</code></li>
</ul>

<hr/><h1>DDL API</h1>

<p>The DDL API are a collection of functions and structures that allows for DDL source code compilation and subsequent querying of the components found in the source file for i.e. code generation.</p>

<h2>Common methods</h2>

<p>Many structures present a set of common methods that are explained here.</p>

<h3><code>const char* GetName() const</code></h3>

<p>Returns the name of the component, i.e. a select's name or a structure's field's name.</p>

<h3><code>const char* GetAuthor() const</code></h3>

<p>If the component has been tagged with the <code>author</code> tag, <code>GetAuthor</code> returns the contents of the tag, otherwise it returns NULL. This tag can be used to document the person who authored the component.</p>

<h3><code>const char* GetDescription() const</code></h3>

<p>If the component has been tagged with the <code>description</code> tag, <code>GetDescription</code> returns the contents of the tag, otherwise it returns NULL. This tag can be used to give the component a verbose description.</p>

<h3><code>const char* GetLabel() const</code></h3>

<p>If the component has been tagged with the <code>label</code> tag, <code>GetLabel</code> returns the contents of the tag, otherwise it returns NULL. This tag can be used to give the component a label to be used in the user interface, for example.</p>

<h3><code>const char* GetDisplayLabel() const</code></h3>

<p>Returns the contents of the <code>label</code> tag if it has been defined and is not the empty string. Otherwise it returns the name of the component.</p>

<h3><code>uint32_t GetNameHash() const</code></h3>

<p>Returns the hash of the components's name. The hash is created with DDLParser::StringCrc32.</p>

<h3><code>DDLParser::Tag* GetTags() const</code></h3>

<p>Returns the first tag defined for the component, or NULL if the component has no tags defined.</p>

<h3><code>DDLParser::Tag* GetTag( uint32_t type ) const</code></h3>

<p>Finds and returns a tag by its type. Alternatively, type can be the hash of the generic tag to be searched for. Either way, if the tag isn't found NULL is returned.</p>

<hr/><h1>DDLParser::Compile</h1>

<code>DDLParser::Definition* DDLParser::Compile( DDLParser::LinearAllocator* definition, DDLParser::LinearAllocator* scratch, const void* source, size_t source_size, char* error, size_t error_size, bool two_us_reserved, int bitfield_limit )</code>
<p>The DDLParser::Compile function compiles a DDL source file into a DDLParser::Definition ready to be used to generate code.</p>

<h2>Parameters</h2>

<ul>
<li><code>definition</code>: A DDLParser::LinearAllocator where the definition is assembled. When DDLParser::Compile returns, this allocator will have the complete definition.</li>
<li><code>scratch</code>: A DDLParser::LinearAllocator used for temporary work. Can be discarded after DDLParser::Compile returns.</li>
<li><code>source</code>: A pointer to the DDL source code. This buffer doesn't have to be null-terminated and cannot be NULL.</li>
<li><code>source_size</code>: The size of the <code>source</code> buffer.</li>
<li><code>error</code>: A pointer to a buffer where the error message, if there's one, will be written to. Cannot be NULL.</li>
<li><code>error_size</code>: The size of the <code>error</code> buffer.</li>
<li><code>two_us_reserved</code>: If true, identifiers starting with two underlines are reserved and disallowed in the source code.</li>
<li><code>bitfield_limit</code>: The maximum number of flags allowed in a bitfield. If this value is zero, there is no limit on the number of flags per bitfield.</li>
</ul>

<h2>Return value</h2>

<p>If the parse succeeds it returns the definition assembled in <code>definition</code> casted to a DDLParser::Definition pointer. If there was an error, DDLParser::Compile returns NULL and <code>error</code> is filled with the error message.</p>

<hr/><h1>DDLParser::StringCrc32</h1>

<p><code>uint32_t DDLParser::StringCrc32( const char* data )</code></p>

<p>Returns the CRC32 of the string.</p>

<hr/><h1>DDLParser::Definition</h1>

<p>After a successful parsing, DDLParser::Compile returns a DDLParser::Definition, which is used as the starting point to query all selects, bitfields, and structures, defined in the source code.</p>

<p>DDLParser::Definition has the following methods:</p>

<h2><code>uint32_t DDLParser::Definition::GetNumAggregates() const</code></h2>

<p>Returns the number of aggregates (selects, bitfields and structures) in the definition.</p>

<h2><code>uint32_t DDLParser::Definition::GetTotalSize() const</code></h2>

<p>Returns the total size in bytes of the definition. This can be used if you want to write it into a file for example.</p>

<h2><code>static DDLParser::Definition* DDLParser::Definition::FromBinRep( void* bin_rep )</code></h2>

<p>Just returns the <code>bin_rep</code> pointer casted to a DDLParser::Definition.</p>

<h2><code>DDLParser::Aggregate* DDLParser::Definition::GetAggregate( unsigned int index )</code></h2>

<p>Returns an aggregate given its index. Aggregates are saved into the definition in the order they appear in the source code. No bounds check is done with <code>index</code>.</p>

<h2><code>DDLParser::Aggregate* DDLParser::Definition::FindAggregate( const char* name )</code></h2>

<p>Finds and returns an aggregate by name. If the aggregate does not exist, NULL is returned.</p>

<h2><code>DDLParser::Aggregate* DDLParser::Definition::FindAggregate( uint32_t hash )</code></h2>

<p>Finds and returns an aggregate by the hash of its name. If the aggregate does not exist, NULL is returned. The hash must be created with DDLParser::StringCrc32.</p>

<hr/><h1>DDLParser::Aggregate</h1>

<p>An aggregate holds information common to selects, bitfields, and structures. It has the following common methods: <code>GetName</code>, <code>GetAuthor</code>, <code>GetDescription</code>, <code>GetLabel</code>, <code>GetDisplayLabel</code>, and <code>GetNameHash</code>.</p>

<h2><code>uint32_t DDLParser::Aggregate::GetType() const</code></h2>

<p>Returns the type of the aggregate, DDLParser::kSelect, DDLParser::kBitfield, or DDLParser::kStruct.</p>

<h2><code>DDLParser::Select* DDLParser::Aggregate::ToSelect() const</code></h2>

<p>Returns the aggregate casted to DDLParser::Select without checking for the actual aggregate type.</p>

<h2><code>DDLParser::Bitfield* DDLParser::Aggregate::ToBitfield() const</code></h2>

<p>Returns the aggregate casted to DDLParser::Bitfield without checking for the actual aggregate type.</p>

<h2><code>DDLParser::Struct* DDLParser::Aggregate::ToStruct() const</code></h2>

<p>Returns the aggregate casted to DDLParser::Struct without checking for the actual aggregate type.</p>

<hr/><h1>DDLParser::Select</h1>

<p>A select is like a C enum, but you can't define the value of the items. Their value is always the hash code of their identifiers. A select holds information about its items.</p>

<p>In addition to the methods listed here, selects have the following common methods: <code>GetName</code>, <code>GetAuthor</code>, <code>GetDescription</code>, <code>GetLabel</code>, <code>GetDisplayLabel</code>, <code>GetNameHash</code>, <code>GetTags</code>, and <code>GetTag</code>.</p>

<h2><code>uint32_t DDLParser::Select::GetNumItems() const</code></h2>

<p>Returns the number of items contained in the select.</p>

<h2><code>int32_t DDLParser::Select::GetDefaultItem() const</code></h2>

<p>Returns the index of the item defined as the default item for the select. If no item was defined as the default, the default item is the first defined. This can be used to initialize variables to a default value if none is given for example.</p>

<h2><code>DDLParser::SelectItem* DDLParser::Select::FindItem( const char* name )</code></h2>

<p>Finds and returns an item by name. If the item does not exist, NULL is returned.</p>

<h2><code>DDLParser::SelectItem* DDLParser::Select::FindItem( uint32_t hash )</code></h2>

<p>Finds and returns an item by the hash of its name. If the item does not exist, NULL is returned. The hash must be created with DDLParser::StringCrc32.</p>

<hr/><h1>DDLParser::SelectItem</h1>

<p>A select item represents an item declared in a select and has the following common methods: <code>GetName</code>, <code>GetAuthor</code>, <code>GetDescription</code>, <code>GetLabel</code>, <code>GetDisplayLabel</code>, <code>GetNameHash</code>, <code>GetTags</code>, and <code>GetTag</code>.</p>

<p>Select items doesn't have any particular method besides the common ones listed above.</p>

<hr/><h1>DDLParser::Bitfield</h1>

<p>A bitfield is a set, and bitfield flags are the set's items. Unlike select items, a bitfield flag has a value associated to it. This value can be an explicit zero, an unique, automatically assigned value or a set which is the union of other flags. If the value is automatically assigned, it starts with one and is incremented for each assignment.</p>

<p>In addition to the methods listed here, bitfields have the following common methods: <code>GetName</code>, <code>GetAuthor</code>, <code>GetDescription</code>, <code>GetLabel</code>, <code>GetDisplayLabel</code>, <code>GetNameHash</code>, <code>GetTags</code>, and <code>GetTag</code>.</p>

<h2><code>uint32_t DDLParser::Bitfield::GetNumFlags() const</code></h2>

<p>Returns the number of flags contained in the bitfield.</p>

<h2><code>int32_t DDLParser::Bitfield::GetDefaultFlag() const</code></h2>

<p>Returns the index of the flag defined as the default flag for the bitfield. If no flag was defined as the default, the default item is the empty flag. If an empty flag wasn't declared, The first flag is elected the default. This can be used to initialize variables to a default value if none is given for example.</p>

<h2><code>DDLParser::BitfieldFlag* DDLParser::Bitfield::FindFlag( const char* name )</code></h2>

<p>Finds and returns a flag by name. If the flag does not exist, NULL is returned.</p>

<h2><code>DDLParser::BitfieldFlag* DDLParser::Bitfield::FindFlag( uint32_t hash )</code></h2>

<p>Finds and returns a flag by the hash of its name. If the flag does not exist, NULL is returned. The hash must be created with DDLParser::StringCrc32.</p>

<hr/><h1>DDLParser::BitfieldFlag</h1>

<p>A flag is a unique element in a set, or a set of other flags. A flag has the following common methods: <code>GetName</code>, <code>GetAuthor</code>, <code>GetDescription</code>, <code>GetLabel</code>, <code>GetDisplayLabel</code>, <code>GetNameHash</code>, <code>GetTags</code>, and <code>GetTag</code>.</p>

<p>Flags also have the following unique methods:</p>

<h2><code>DDLParser::BitfieldFlagValue* DDLParser::BitfieldFlag::GetValue() const</code></h2>

<p>Returns the value of the flag in case it's the empty flag or a set. If neither is true, this function returns NULL.</p>

<h2><code>uint32_t DDLParser::BitfieldFlag::GetBit() const</code></h2>

<p>If the flag is the empty flag, or if it's a set, this functions returns zero. Otherwise, it returns an automatically assigned value for the flag which is unique in the bitfield. This values starts at one and is incremented for each flag that uses it. It can be used to generate code for flags as bits in an integer, i.e. <code>1 << ( flag->GetBit() - 1 )</code>.</p>

<hr/><h1>DDLParser::BitfieldFlagValue</h1>

<p>Defines the value of a flag when it's either the empty flag or a set.</p>

<h2><code>uint32_t DDLParser::BitfieldFlagValue::GetCount() const</code></h2>

<p>If the flag is the empty flag, this function returns zero. Otherwise, it returns the number of flags contained in the flag.</p>

<h2><code>uint32_t DDLParser::BitfieldFlagValue::GetFlagIndex( uint32_t index ) const</code></h2>

<p>Returns the index of the flag which is part of this set.</p>

<h2>Bitfield example</h2>

<p>As an example, this code generates C++ code that outputs a bitfield's flags as bits in an unsigned integer:</p>

<code><pre><span class="keyword">static</span><span class="type"> void</span> GenerateBitfield<span class="operator">(</span> DDLParser<span class="operator">:</span><span class="operator">:</span>Bitfield<span class="operator">*</span> bitfield<span class="operator"> )</span><span class="operator">
{</span>
  printf<span class="operator">(</span><span class="string"> "namespace %s\n"</span><span class="operator">,</span> bitfield<span class="operator">-</span><span class="operator">></span>GetName<span class="operator">(</span><span class="operator">)</span><span class="operator"> )</span><span class="operator">;</span>
  printf<span class="operator">(</span><span class="string"> "{\n"</span><span class="operator"> )</span><span class="operator">;</span><span class="flow">
  for</span><span class="operator"> (</span><span class="type"> uint32_t</span> i<span class="operator"> =</span><span class="int"> 0</span><span class="operator">;</span> i<span class="operator"> <</span> bitfield<span class="operator">-</span><span class="operator">></span>GetNumFlags<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span> i<span class="operator">+</span><span class="operator">+</span><span class="operator"> )</span><span class="operator">
  {</span>
    DDLParser<span class="operator">:</span><span class="operator">:</span>BitfieldFlag<span class="operator">*</span> flag<span class="operator"> =</span> bitfield<span class="operator">-</span><span class="operator">></span>GetFlag<span class="operator">(</span> i<span class="operator"> )</span><span class="operator">;</span>
    DDLParser<span class="operator">:</span><span class="operator">:</span>BitfieldFlagValue<span class="operator">*</span> value<span class="operator"> =</span> flag<span class="operator">-</span><span class="operator">></span>GetValue<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>
    printf<span class="operator">(</span><span class="string"> "  static const uint32_t %-20s = "</span><span class="operator">,</span> flag<span class="operator">-</span><span class="operator">></span>GetName<span class="operator">(</span><span class="operator">)</span><span class="operator"> )</span><span class="operator">;</span><span class="flow">
    if</span><span class="operator"> (</span> value<span class="operator"> =</span><span class="operator">=</span> NULL<span class="operator"> )</span><span class="operator">
    {</span><span class="comment">
      // The flag has an automatically assigned value.</span>
      printf<span class="operator">(</span><span class="string"> "0x%08x;\n"</span><span class="operator">,</span><span class="int"> 1</span><span class="operator"> <</span><span class="operator"><</span><span class="operator"> (</span> flag<span class="operator">-</span><span class="operator">></span>GetBit<span class="operator">(</span><span class="operator">)</span><span class="operator"> -</span><span class="int"> 1</span><span class="operator"> )</span><span class="operator"> )</span><span class="operator">;</span><span class="operator">
    }</span><span class="flow">
    else</span><span class="operator">
    {</span><span class="flow">
      if</span><span class="operator"> (</span> value<span class="operator">-</span><span class="operator">></span>GetCount<span class="operator">(</span><span class="operator">)</span><span class="operator"> =</span><span class="operator">=</span><span class="int"> 0</span><span class="operator"> )</span><span class="operator">
      {</span><span class="comment">
        // The flag is the empty flag.</span>
        printf<span class="operator">(</span><span class="string"> "0x%08x;\n"</span><span class="operator">,</span><span class="int"> 0</span><span class="operator"> )</span><span class="operator">;</span><span class="operator">
      }</span><span class="flow">
      else</span><span class="operator">
      {</span><span class="comment">
        // The flag is a set containing other flags.</span>
        DDLParser<span class="operator">:</span><span class="operator">:</span>BitfieldFlag<span class="operator">*</span> other<span class="operator"> =</span> bitfield<span class="operator">-</span><span class="operator">></span>GetFlag<span class="operator">(</span><span class="int"> 0</span><span class="operator"> )</span><span class="operator">;</span>
        printf<span class="operator">(</span><span class="string"> "%s"</span><span class="operator">,</span> other<span class="operator">-</span><span class="operator">></span>GetName<span class="operator">(</span><span class="operator">)</span><span class="operator"> )</span><span class="operator">;</span><span class="flow">
        for</span><span class="operator"> (</span><span class="type"> uint32_t</span> j<span class="operator"> =</span><span class="int"> 1</span><span class="operator">;</span> j<span class="operator"> <</span> value<span class="operator">-</span><span class="operator">></span>GetCount<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span> j<span class="operator">+</span><span class="operator">+</span><span class="operator"> )</span><span class="operator">
        {</span>
          other<span class="operator"> =</span> bitfield<span class="operator">-</span><span class="operator">></span>GetFlag<span class="operator">(</span> value<span class="operator">-</span><span class="operator">></span>GetFlagIndex<span class="operator">(</span> j<span class="operator"> )</span><span class="operator"> )</span><span class="operator">;</span>
          printf<span class="operator">(</span><span class="string"> " | %s"</span><span class="operator">,</span> other<span class="operator">-</span><span class="operator">></span>GetName<span class="operator">(</span><span class="operator">)</span><span class="operator"> )</span><span class="operator">;</span><span class="operator">
        }</span>
        printf<span class="operator">(</span><span class="string"> ";\n"</span><span class="operator"> )</span><span class="operator">;</span><span class="operator">
      }</span><span class="operator">
    }</span><span class="operator">
  }</span>
  printf<span class="operator">(</span><span class="string"> "}\n"</span><span class="operator"> )</span><span class="operator">;</span><span class="operator">
}</span></pre></code>

<hr/><h1>DDLParser::Struct</h1>

<p>Structures are collections of fields. Each field has its own type, which can be a native type, a select, a bitfield, another structure, a fixed or dynamic array of the previous types, or a hashmap mapping an integer, a string, a file, or a tuid to any other type.</p>

<p>In addition to the methods listed here, structures have the following common methods: <code>GetName</code>, <code>GetAuthor</code>, <code>GetDescription</code>, <code>GetLabel</code>, <code>GetDisplayLabel</code>, <code>GetNameHash</code>, <code>GetTags</code>, and <code>GetTag</code>.</p>

<h2><code>uint32_t DDLParser::Struct::GetNumFields() const</code></h2>

<p>Returns the number of fields contained in the structure.</p>

<h2><code>DDLParser::Struct* DDLParser::Struct::GetParent() const</code></h2>

<p>Returns the parent structure of this structure. If the structure doesn't inherit from another structure, it returns NULL.</p>

<h2><code>DDLParser::Definition* DDLParser::Struct::GetDefinition() const</code></h2>

<p>Returns the definition where the structure was defined.</p>

<h2><code>DDLParser::StructField* DDLParser::Struct::FindField( const char* name )</code></h2>

<p>Finds and returns a field by name. If the field does not exist, NULL is returned.</p>

<h2><code>DDLParser::StructField* DDLParser::Struct::FindField( uint32_t hash )</code></h2>

<p>Finds and returns a field by the hash of its name. If the field does not exist, NULL is returned. The hash must be created with DDLParser::StringCrc32.</p>

<h2><code>bool DDLParser::Struct::IsInherited( DDLParser::StructField* field )</code></h2>

<p>Returns <code>true</code> if the field is from a parent structure.</p>

<h2><code>uint32_t DDLParser::Struct::GetSchemaCrc() const</code></h2>

<p>The schema crc reflects the type, count, name, and order of each field. If any of those change, then the crc changes. It does not reflect default values or any tags.</p>

<hr/><h1>DDLParser::StructField</h1>

<p>A field is an instance of a given type. A field has these common methods: <code>GetName</code>, <code>GetAuthor</code>, <code>GetDescription</code>, <code>GetLabel</code>, <code>GetDisplayLabel</code>, <code>GetNameHash</code>, <code>GetTags</code>, and <code>GetTag</code>.</p>

<p>Fields also have the following unique method.</p>

<h2><code>DDLParser::StructValueInfo* DDLParser::StructField::GetValueInfo()</code></h2>

<p>Returns the value information of the field. A field always have a DDLParser::StructField::GetValueInfo so this method never returns NULL.</p>

<hr/><h1>DDLParser::StructValueInfo</h1>

<p>A DDLParser::StructValueInfo holds information for both a field declared in a structure and its default values if the field has a structure for its type. It has the the <code>GetTags</code> and <code>GetTag</code> common methods.</p>

<h2><code>uint32_t DDLParser::StructValueInfo::GetNameHash() const</code></h2>

<p>Returns the hash of the field's name.</p>

<h2><code>Type DDLParser::StructValueInfo::GetType() const</code></h2>

<p>Returns the type of the field which is a value from the DDLParser::Type enumeration.</p>

<h2><code>uint32_t DDLParser::StructValueInfo::GetTypeNameHash() const</code></h2>

<p>Returns the hash of the field's type name. Only usefull if the field has a select, bitfield or structure type so it's possible to query the definition for the actual aggregate.</p>

<h2><code>const char* DDLParser::StructValueInfo::GetTypeName() const</code></h2>

<p>Deprecated.</p>

<h2><code>ArrayType DDLParser::StructValueInfo::GetArrayType() const</code></h2>

<p>Returns the array type of the field. Possible values are DDLParser::kScalar (the field is not an array), DDLParser::kFixed (the field is an array with a fixed dimension), DDLParser::kDynamic (the field is an array without an specified dimention) and DDLParser::kHashmap (the field is a hashmap), from the DDLParser::ArrayType enumeration.</p>

<h2><code>DDLParser::StructFieldValue* DDLParser::StructValueInfo::GetValue() const</code></h2>

<p>Returns the array of default values for the field. If the field hasn't a default value, it returns NULL. Only scalar and fixed array types of fields can have a default value. In the former, only the first position of the array of values is valid. In the later, the array of values is valid from 0 to DDLParser::StructValueInfo::GetCount.</p>

<h2><code>uint32_t DDLParser::StructValueInfo::GetCount() const</code></h2>

<p>Returns the size of the array if the array is fixed. Always returns one for scalars and zero for dynamic arrays and hashmaps.</p>

<h2><code>uint32_t DDLParser::StructValueInfo::GetKeyType() const</code></h2>

<p>Returns the DDL type of a hashmap key. If the field is not a hashmap, this method doesn't return anything meaningful.</p>

<h2><code>int DDLParser::StructValueInfo::GetKeyBitSize() const</code></h2>

<p>Convenience method that returns the bit size of the hashmap key. Returns 64 for DDLParser::kInt64, DDLParser::kUint64, DDLParser::kFloat64, and DDLParser::kTuid, and 32 for all other types.</p>

<h2><code>bool DDLParser::StructValueInfo::AllowSubStruct() const</code></h2>

<p>Convenience method that returns <code>true</code> if the field was tagged with the <code>tag( AllowSubstruct )</code>' generic tag.</p>

<h2><code>uint32_t DDLParser::StructValueInfo::GetSchemaCrc() const</code></h2>

<p>The schema crc reflects the type, count, and name of the field. If any of those change, then the crc changes. It does not reflect default values or any tags.</p>

<h2><code>DDLParser::Aggregate* DDLParser::StructValueInfo::GetAggregate( Definition* ddl ) const</code>'</h2>

<p>Returns the aggregate which is the type of the field. If the field has not a select, bitfield or structure as its type, this method returns NULL.</p>

<hr/><h1>DDLParser::StructFieldValue</h1>

<p>DDLParser::StructFieldValue is an union which holds the values defined for fields.</p>

<code><pre><span class="keyword">union</span> DDLParser<span class="operator">:</span><span class="operator">:</span>StructFieldValue<span class="operator">
{</span><span class="type">
  uint8_t</span>                m_Uint8<span class="operator">[</span><span class="int"> 0</span><span class="operator"> ]</span><span class="operator">;</span><span class="type">
  uint16_t</span>               m_Uint16<span class="operator">[</span><span class="int"> 0</span><span class="operator"> ]</span><span class="operator">;</span><span class="type">
  uint32_t</span>               m_Uint32<span class="operator">[</span><span class="int"> 0</span><span class="operator"> ]</span><span class="operator">;</span><span class="type">
  uint64_t</span>               m_Uint64<span class="operator">[</span><span class="int"> 0</span><span class="operator"> ]</span><span class="operator">;</span><span class="type">
  int8_t</span>                 m_Int8<span class="operator">[</span><span class="int"> 0</span><span class="operator"> ]</span><span class="operator">;</span><span class="type">
  int16_t</span>                m_Int16<span class="operator">[</span><span class="int"> 0</span><span class="operator"> ]</span><span class="operator">;</span><span class="type">
  int32_t</span>                m_Int32<span class="operator">[</span><span class="int"> 0</span><span class="operator"> ]</span><span class="operator">;</span><span class="type">
  int64_t</span>                m_Int64<span class="operator">[</span><span class="int"> 0</span><span class="operator"> ]</span><span class="operator">;</span><span class="type">
  float</span>                  m_Float32<span class="operator">[</span><span class="int"> 0</span><span class="operator"> ]</span><span class="operator">;</span><span class="type">
  double</span>                 m_Float64<span class="operator">[</span><span class="int"> 0</span><span class="operator"> ]</span><span class="operator">;</span>
  String                 m_String<span class="operator">[</span><span class="int"> 0</span><span class="operator"> ]</span><span class="operator">;</span><span class="type">
  uint32_t</span>               m_Select<span class="operator">[</span><span class="int"> 0</span><span class="operator"> ]</span><span class="operator">;</span>
  StructBitfieldValuePtr m_Bitfield<span class="operator">[</span><span class="int"> 0</span><span class="operator"> ]</span><span class="operator">;</span>
  StructStructValuePtr   m_Struct<span class="operator">[</span><span class="int"> 0</span><span class="operator"> ]</span><span class="operator">;</span>
  StructUnknownValuePtr  m_Unknown<span class="operator">[</span><span class="int"> 0</span><span class="operator"> ]</span><span class="operator">;</span><span class="comment"> // Deprecated</span><span class="type">
  uint8_t</span>                m_Boolean<span class="operator">[</span><span class="int"> 0</span><span class="operator"> ]</span><span class="operator">;</span>
  String                 m_File<span class="operator">[</span><span class="int"> 0</span><span class="operator"> ]</span><span class="operator">;</span><span class="type">
  uint64_t</span>               m_Tuid<span class="operator">[</span><span class="int"> 0</span><span class="operator"> ]</span><span class="operator">;</span>
  String                 m_Json<span class="operator">[</span><span class="int"> 0</span><span class="operator"> ]</span><span class="operator">;</span><span class="operator">
}</span></pre></code>

<p>When a field's DDLParser::StructValueInfo has a pointer to a DDLParser::StructFieldValue (via DDLParser::StructValueInfo::GetValue), it means the field has default values. The member of the union that is to be accessed depends on DDLParser::StructValueInfo::GetType, and how many entries are valid depends on the field's array type. For DDLParser::kScalar fields, one position only is valid. For DDLParser::kFixed fields, positions from zero to DDLParser::StructValueInfo::GetCount<code> - 1</code> are valid. DDLParser::kDynamic and DDLParser::kHashmap fields don't have default values.</p>

<hr/><h1>DDLParser::StructBitfieldValue</h1>

<p>When a field is of a bitfield type and has a default value, this value is held in the <code>m_Bitfield</code> member of the DDLParser::StructFieldValue union. It has the following methods:</p>

<h2><code>uint32_t DDLParser::StructBitfieldValue::GetCount() const</code></h2>

<p>Returns the number of flags that make the default value of the field.</p>

<h2><code>uint32_t DDLParser::StructBitfieldValue::GetHash( uint32_t index ) const</code></h2>

<p>Returns the hash of the flag at the given index. This hash can be used to get the actual flag from the bitfield via DDLParser::Bitfield::FindFlag.</p>

<hr/><h1>DDLParser::StructStructValue</h1>

<p>When a field is of a structure type and has a default value, it's default value is held in the <code>m_Struct</code> member of the DDLParser::StructFieldValue union. For each field receiving a default value, DDLParser::StructStructValue has a DDLParser::StructValueInfo with details of which field is being initialized and what value it's receiving.</p>

<p>DDLParser::StructStructValue has the following methods:</p>

<h2><code>uint32_t DDLParser::StructStructValue::GetCount() const</code></h2>

<p>Returns the number of value infos in this structure value.</p>

<h2><code>DDLParser::StructValueInfo* DDLParser::StructStructValue::GetValueInfo( uint32_t index ) const</code></h2>

<p>Returns the value info at the given index.</p>

<h2>Example</h2>

<code><pre><span class="keyword">struct</span> A<span class="operator">
{</span><span class="type">
  uint32_t</span> a<span class="operator">,</span><span class="keyword"> value</span><span class="operator">(</span><span class="int"> 1</span><span class="operator"> )</span><span class="operator">;</span><span class="type">
  uint32_t</span> b<span class="operator">;</span><span class="operator">
}</span><span class="keyword">
struct</span> B<span class="operator">
{</span><span class="type">
  uint32_t</span><span class="operator">[</span><span class="int"> 2</span><span class="operator"> ]</span> c<span class="operator">,</span><span class="keyword"> value</span><span class="operator">(</span><span class="operator"> {</span><span class="int"> 1</span><span class="operator">,</span><span class="int"> 2</span><span class="operator"> }</span><span class="operator"> )</span><span class="operator">;</span><span class="type">
  uint32_t</span><span class="operator">[</span><span class="operator">]</span> d<span class="operator">;</span>
  string<span class="operator">{</span><span class="type"> uint32_t</span><span class="operator"> }</span> f<span class="operator">;</span>
  A g<span class="operator">,</span><span class="keyword"> value</span><span class="operator">(</span><span class="operator"> {</span> a<span class="operator"> =</span><span class="int"> 2</span><span class="operator"> }</span><span class="operator"> )</span><span class="operator">;</span><span class="operator">
}</span></pre></code>

<p>The DDLParser::StructValueInfo for the fields declared in the DDL code above are:</p>

<p><table border="1" width="80%" cellspacing="0" cellpadding="3">
<tr><th colspan="3" bgcolor="#e0e0e0"><code>A.a</code></th></tr>
<tr><th width="15%">Method</th><th width="15%">Return Value</th><th>Meaning</th></tr>
<tr><td width="15%"><code>GetNameHash()</code></td><td align="right" width="15%">0x0136c985</td><td>DDLParser::StringCrc32 of <code>a</code>, the field name.</td></tr>
<tr><td width="15%"><code>GetType()</code></td><td align="right" width="15%">2</td><td>DDLParser::kUint32.</td></tr>
<tr><td width="15%"><code>GetTypeNameHash()</code></td><td align="right" width="15%">0x0d5d2ca7</td><td>DDLParser::StringCrc32 of <code>uint32_t</code>, but meaningless.</td></tr>
<tr><td width="15%"><code>GetArrayType()</code></td><td align="right" width="15%">0</td><td>DDLParser::kScalar.</td></tr>
<tr><td width="15%"><code>GetValue()</code></td><td align="right" width="15%">0x009d0074</td><td>The address of the DDLParser::StructFieldValue, since this field has a default value defined for it. This DDLParser::StructFieldValue has the value 1 at <code>m_Uint32[ 0 ]</code>.</td></tr>
<tr><td width="15%"><code>GetTags()</code></td><td align="right" width="15%">0x00000000</td><td>NULL since this field doesn't have any tag.</td></tr>
<tr><td width="15%"><code>GetKeyType()</code></td><td align="right" width="15%">0</td><td>Meaningless.</td></tr>
<tr><td width="15%"><code>GetKeyBitSize()</code></td><td align="right" width="15%">32</td><td>Meaningless.</td></tr>
<tr><td width="15%"><code>GetAggregate()</code></td><td align="right" width="15%">0x00000000</td><td>NULL since this field has a scalar type.</td></tr>
<tr><td width="15%"><code>GetCount()</code></td><td align="right" width="15%">1</td><td>This field holds one <code>uint32_t</code> value.</td></tr>
</table></p>

<p><table border="1" width="80%" cellspacing="0" cellpadding="3">
<tr><th colspan="3" bgcolor="#e0e0e0"><code>A.b</code></th></tr>
<tr><th width="15%">Method</th><th width="15%">Return Value</th><th>Meaning</th></tr>
<tr><td width="15%"><code>GetNameHash()</code></td><td align="right" width="15%">0x983f983f</td><td>DDLParser::StringCrc32 of <code>a</code>, the field name.</td></tr>
<tr><td width="15%"><code>GetType()</code></td><td align="right" width="15%">2</td><td>DDLParser::kUint32.</td></tr>
<tr><td width="15%"><code>GetTypeNameHash()</code></td><td align="right" width="15%">0x0d5d2ca7</td><td>DDLParser::StringCrc32 of <code>uint32_t</code>, but meaningless.</td></tr>
<tr><td width="15%"><code>GetArrayType()</code></td><td align="right" width="15%">0</td><td>DDLParser::kScalar.</td></tr>
<tr><td width="15%"><code>GetValue()</code></td><td align="right" width="15%">0x00000000</td><td>NULL since this field hasn't a default value defined for it.</td></tr>
<tr><td width="15%"><code>GetTags()</code></td><td align="right" width="15%">0x00000000</td><td>NULL since this field doesn't have any tag.</td></tr>
<tr><td width="15%"><code>GetKeyType()</code></td><td align="right" width="15%">0</td><td>Meaningless.</td></tr>
<tr><td width="15%"><code>GetKeyBitSize()</code></td><td align="right" width="15%">32</td><td>Meaningless.</td></tr>
<tr><td width="15%"><code>GetAggregate()</code></td><td align="right" width="15%">0x00000000</td><td>NULL since this field has a scalar type.</td></tr>
<tr><td width="15%"><code>GetCount()</code></td><td align="right" width="15%">1</td><td>This field holds one <code>uint32_t</code> value.</td></tr>
</table></p>

<p><table border="1" width="80%" cellspacing="0" cellpadding="3">
<tr><th colspan="3" bgcolor="#e0e0e0"><code>B.c</code></th></tr>
<tr><th width="15%">Method</th><th width="15%">Return Value</th><th>Meaning</th></tr>
<tr><td width="15%"><code>GetNameHash()</code></td><td align="right" width="15%">0xef38a8a9</td><td>DDLParser::StringCrc32 of <code>c</code>, the field name.</td></tr>
<tr><td width="15%"><code>GetType()</code></td><td align="right" width="15%">2</td><td>DDLParser::kUint32.</td></tr>
<tr><td width="15%"><code>GetTypeNameHash()</code></td><td align="right" width="15%">0x0d5d2ca7</td><td>DDLParser::StringCrc32 of <code>uint32_t</code>, but meaningless.</td></tr>
<tr><td width="15%"><code>GetArrayType()</code></td><td align="right" width="15%">1</td><td>DDLParser::kFixed.</td></tr>
<tr><td width="15%"><code>GetValue()</code></td><td align="right" width="15%">0x00780128</td><td>The address of the DDLParser::StructFieldValue, since this field has a default value defined for it. This DDLParser::StructFieldValue has the values 1 and 2 at <code>m_Uint32[ 0 ]</code> and <code>m_Uint32[ 1 ]</code>.</td></tr>
<tr><td width="15%"><code>GetTags()</code></td><td align="right" width="15%">0x00000000</td><td>NULL since this field doesn't have any tag.</td></tr>
<tr><td width="15%"><code>GetKeyType()</code></td><td align="right" width="15%">0</td><td>Meaningless.</td></tr>
<tr><td width="15%"><code>GetKeyBitSize()</code></td><td align="right" width="15%">32</td><td>Meaningless.</td></tr>
<tr><td width="15%"><code>GetAggregate()</code></td><td align="right" width="15%">0x00000000</td><td>NULL since this field has a scalar type.</td></tr>
<tr><td width="15%"><code>GetCount()</code></td><td align="right" width="15%">2</td><td>This field holds two <code>uint32_t</code> values.</td></tr>
</table></p>

<p><table border="1" width="80%" cellspacing="0" cellpadding="3">
<tr><th colspan="3" bgcolor="#e0e0e0"><code>B.d</code></th></tr>
<tr><th width="15%">Method</th><th width="15%">Return Value</th><th>Meaning</th></tr>
<tr><td width="15%"><code>GetNameHash()</code></td><td align="right" width="15%">0x715c3d0a</td><td>DDLParser::StringCrc32 of <code>d</code>, the field name.</td></tr>
<tr><td width="15%"><code>GetType()</code></td><td align="right" width="15%">2</td><td>DDLParser::kUint32.</td></tr>
<tr><td width="15%"><code>GetTypeNameHash()</code></td><td align="right" width="15%">0x0d5d2ca7</td><td>DDLParser::StringCrc32 of <code>uint32_t</code>, but meaningless.</td></tr>
<tr><td width="15%"><code>GetArrayType()</code></td><td align="right" width="15%">2</td><td>DDLParser::kDynamic.</td></tr>
<tr><td width="15%"><code>GetValue()</code></td><td align="right" width="15%">0x00000000</td><td>NULL since this field hasn't (and can't have) a default value defined for it.</td></tr>
<tr><td width="15%"><code>GetTags()</code></td><td align="right" width="15%">0x00000000</td><td>NULL since this field doesn't have any tag.</td></tr>
<tr><td width="15%"><code>GetKeyType()</code></td><td align="right" width="15%">0</td><td>Meaningless.</td></tr>
<tr><td width="15%"><code>GetKeyBitSize()</code></td><td align="right" width="15%">32</td><td>Meaningless.</td></tr>
<tr><td width="15%"><code>GetAggregate()</code></td><td align="right" width="15%">0x00000000</td><td>NULL since this field has a scalar type.</td></tr>
<tr><td width="15%"><code>GetCount()</code></td><td align="right" width="15%">0</td><td>This field is a dynamic array, which initialy has no elements.</td></tr>
</table></p>

<p><table border="1" width="80%" cellspacing="0" cellpadding="3">
<tr><th colspan="3" bgcolor="#e0e0e0"><code>B.f</code></th></tr>
<tr><th width="15%">Method</th><th width="15%">Return Value</th><th>Meaning</th></tr>
<tr><td width="15%"><code>GetNameHash()</code></td><td align="right" width="15%">0x9f525c26</td><td>DDLParser::StringCrc32 of "f", the field name.</td></tr>
<tr><td width="15%"><code>GetType()</code></td><td align="right" width="15%">10</td><td>DDLParser::kString.</td></tr>
<tr><td width="15%"><code>GetTypeNameHash()</code></td><td align="right" width="15%">0xa76af9f8</td><td>DDLParser::StringCrc32 of "string", but meaningless.</td></tr>
<tr><td width="15%"><code>GetArrayType()</code></td><td align="right" width="15%">3</td><td>DDLParser::kHashmap.</td></tr>
<tr><td width="15%"><code>GetValue()</code></td><td align="right" width="15%">0x00000000</td><td>NULL since this field hasn't (and can't have) a default value defined for it.</td></tr>
<tr><td width="15%"><code>GetTags()</code></td><td align="right" width="15%">0x00000000</td><td>NULL since this field doesn't have any tag.</td></tr>
<tr><td width="15%"><code>GetKeyType()</code></td><td align="right" width="15%">2</td><td>DDLParser::kUint32.</td></tr>
<tr><td width="15%"><code>GetKeyBitSize()</code></td><td align="right" width="15%">32</td><td>The size of the key of this hashmap, in bits.</td></tr>
<tr><td width="15%"><code>GetAggregate()</code></td><td align="right" width="15%">0x00000000</td><td>NULL since this field has a scalar type (strings are scalars in DDL).</td></tr>
<tr><td width="15%"><code>GetCount()</code></td><td align="right" width="15%">0</td><td>This field is a hashmap, which initialy has no elements.</td></tr>
</table></p>

<p><table border="1" width="80%" cellspacing="0" cellpadding="3">
<tr><th colspan="3" bgcolor="#e0e0e0"><code>B.g</code></th></tr>
<tr><th width="15%">Method</th><th width="15%">Return Value</th><th>Meaning</th></tr>
<tr><td width="15%"><code>GetNameHash()</code></td><td align="right" width="15%">0xe8556cb0</td><td>DDLParser::StringCrc32 of "g", the field name.</td></tr>
<tr><td width="15%"><code>GetType()</code></td><td align="right" width="15%">13</td><td>DDLParser::kStruct.</td></tr>
<tr><td width="15%"><code>GetTypeNameHash()</code></td><td align="right" width="15%">0x3a58e94d</td><td>DDLParser::StringCrc32 of "A", the name of the aggregate which is the type of this field.</td></tr>
<tr><td width="15%"><code>GetArrayType()</code></td><td align="right" width="15%">0</td><td>DDLParser::kScalar.</td></tr>
<tr><td width="15%"><code>GetValue()</code></td><td align="right" width="15%">0x007801e4</td><td>The address of the DDLParser::StructFieldValue, since this field has a default value defined for it. This DDLParser::StructFieldValue has a DDLParser::StructStructValue pointer at <code>m_Struct[ 0 ]</code>.</td></tr>
<tr><td width="15%"><code>GetTags()</code></td><td align="right" width="15%">0x00000000</td><td>NULL since this field doesn't have any tag.</td></tr>
<tr><td width="15%"><code>GetKeyType()</code></td><td align="right" width="15%">0</td><td>Meaningless.</td></tr>
<tr><td width="15%"><code>GetKeyBitSize()</code></td><td align="right" width="15%">32</td><td>Meaningless.</td></tr>
<tr><td width="15%"><code>GetAggregate()</code></td><td align="right" width="15%">0x00780014</td><td>The address of DDLParser::Struct <code>A</code> which is the type of this field.</td></tr>
<tr><td width="15%"><code>GetCount()</code></td><td align="right" width="15%">1</td><td>This field holds one structure <code>A</code> value.</td></tr>
</table></p>

<p>The details of the DDLParser::StructStructValue for <code>B.g</code> are:</p>

<p><table border="1" width="80%" cellspacing="0" cellpadding="3">
<tr><th colspan="3" bgcolor="#e0e0e0">Details of the DDLParser::StructStructValue for <code>B.g</code></th></tr>
<tr><th width="15%">Method</th><th width="15%">Return Value</th><th>Meaning</th></tr>
<tr><td width="15%"><code>GetNameHash()</code></td><td align="right" width="15%">0x0136c985</td><td>DDLParser::StringCrc32 of "a", the name of the field being initialized.</td></tr>
<tr><td width="15%"><code>GetType()</code></td><td align="right" width="15%">2</td><td>DDLParser::kUint32.</td></tr>
<tr><td width="15%"><code>GetTypeNameHash()</code></td><td align="right" width="15%">0x0d5d2ca7</td><td>DDLParser::StringCrc32 of "uint32_t", but meaningless.</td></tr>
<tr><td width="15%"><code>GetArrayType()</code></td><td align="right" width="15%">0</td><td>DDLParser::kScalar.</td></tr>
<tr><td width="15%"><code>GetValue()</code></td><td align="right" width="15%">0x00780214</td><td>The address of the DDLParser::StructFieldValue, since this field has a default value defined for it. This DDLParser::StructFieldValue has the value 2 at <code>m_Uint32[ 0 ]</code>, which overrides the default value 1 of <code>A.a</code>.</td></tr>
<tr><td width="15%"><code>GetTags()</code></td><td align="right" width="15%">0x00000000</td><td>NULL as value infos of fields being initialized can't have tags.</td></tr>
<tr><td width="15%"><code>GetKeyType()</code></td><td align="right" width="15%">0</td><td>Meaningless.</td></tr>
<tr><td width="15%"><code>GetKeyBitSize()</code></td><td align="right" width="15%">32</td><td>Meaningless.</td></tr>
<tr><td width="15%"><code>GetAggregate()</code></td><td align="right" width="15%">0x00000000</td><td>NULL since this field has a scalar type.</td></tr>
<tr><td width="15%"><code>GetCount()</code></td><td align="right" width="15%">1</td><td>This field holds one <code>uint32_t</code> value.</td></tr>
</table></p>

<hr/><h1>DDLParser::Tag</h1>

<p>Tags are decorations that can be added to structures, fields, selects, items, bitfields, and flags. Their purpose is to pass down information to code generators to change the way code is generated for them.</p>

<p>DDLParser::Tag is the parent of all other tags, and has the following methods:</p>

<h2><code>uint32_t DDLParser::Tag::GetType() const</code></h2>

<p>Returns the type of the tag, which is a value from the DDLParser::TagType enum.</p>

<h2><code>DDLParser::Tag* DDLParser::Tag::GetNext() const</code></h2>

<p>The tags of a DDL component form a linked list. <code>GetTags</code> returns the first tag for the component, and DDLParser::Tag::GetNext is used to return the next tag in the linked list. Returns NULL at the end of the list.</p>

<hr/><h1>DDLParser::GenericTag</h1>

<p>All tag types are deprecated, new code should only use generic tags that can be defined without changing the DDL parser. Generic tags have the DDLParser::kGeneric type and the following methods in addition to the methods from DDLParser::Tag:</p>

<h2><code>const char* DDLParser::GenericTag::GetName() const</code></h2>

<p>Returns the identifier used in the tag definition.</p>

<h2><code>uint32_t DDLParser::GenericTag::GetNameHash() const</code></h2>

<p>Returns the hash of the identifier used in the tag definition, created with DDLParser::StringCrc32.</p>

<h2><code>uint32_t DDLParser::GenericTag::GetNumValues() const</code></h2>

<p>Returns the number of values defined in the tag after its name.</p>

<h2><code>DDLParser::GenericTagValue* DDLParser::GenericTag::operator[]( unsigned int index ) const</code></h2>

<p>Returns the value defined for the tag at the given index.</p>

<hr/><h1>DDLParser::GenericTagValue</h1>

<p>Represents a value defined in a generic tag after its name:</p>

<code><pre><span class="keyword">struct</span> DDLParser<span class="operator">:</span><span class="operator">:</span>GenericTagValue<span class="operator">
{</span><span class="type">
  uint32_t</span> m_Type<span class="operator">;</span><span class="keyword">
  union</span><span class="operator">
  {</span><span class="type">
    int64_t</span> m_Int64<span class="operator">;</span><span class="type">
    double</span>  m_Float64<span class="operator">;</span>
    String  m_String<span class="operator">;</span><span class="operator">
  }</span><span class="operator">;</span><span class="operator">
}</span></pre></code>

<p>The <code>m_Type</code> member can be <code>DDLParser::kInt64</code>, <code>DDLParser::kFloat64</code>, or <code>DDLParser::kString</code>. Use this member to know the type of the value and which of the other members to access in a value.</p>

<h2>Validating Generic Tags</h2>

<p>Every time the parser parses a generic tag it calls one of the following callback functions to validate the tag:</p>

<ul>
<li><code>typedef bool DDLParser::CheckStructTag( DDLParser::Definition* def, DDLParser::Struct* structure, DDLParser::GenericTag* tag, DDLParser::Str* tag_name, DDLParser::TagSet* tag_set, char* error, size_t error_size );</code></li>
<li><code>typedef bool DDLParser::CheckFieldTag( DDLParser::Definition* def, DDLParser::Struct* structure, DDLParser::StructField* field, DDLParser::GenericTag* tag, DDLParser::Str* tag_name, DDLParser::TagSet* tag_set, char* error, size_t error_size );</code></li>
<li><code>typedef bool DDLParser::CheckSelectTag( DDLParser::Definition* def, DDLParser::Select* select, DDLParser::GenericTag* tag, DDLParser::Str* tag_name, DDLParser::TagSet* tag_set, char* error, size_t error_size );</code></li>
<li><code>typedef bool DDLParser::CheckItemTag( DDLParser::Definition* def, DDLParser::Select* select, DDLParser::SelectItem* item, DDLParser::GenericTag* tag, DDLParser::Str* tag_name, DDLParser::TagSet* tag_set, char* error, size_t error_size );</code></li>
<li><code>typedef bool DDLParser::CheckBitfieldTag( DDLParser::Definition* def, DDLParser::Bitfield* bitfield, DDLParser::GenericTag* tag, DDLParser::Str* tag_name, DDLParser::TagSet* tag_set, char* error, size_t error_size );</code></li>
<li><code>typedef bool DDLParser::CheckFlagTag( DDLParser::Definition* def, DDLParser::Bitfield* bitfield, DDLParser::BitfieldFlag* flag, DDLParser::GenericTag* tag, DDLParser::Str* tag_name, DDLParser::TagSet* tag_set, char* error, size_t error_size );</code></li>
</ul>

<p>These callbacks must return <code>true</code> to inform the parser that the tag was accepted, or <code>false</code> to inform that it was rejected. In the later case, the callback must also fill the <code>error</code> buffer with an error message up to <code>error_size</code> characters.</p>

<p>If a callback isn't defined, the tag is automatically accepted.</p>

<p>Note: DDLParser::Compile doesn't give the programmer the chance to install callbacks in the parser. For that, duplicate the source code of DDLParser::Compile and add the callbacks as needed.</p>

<hr/><h1>DDLParser::Str</h1>

<p>DDLParser::Str represent internal strings during the parsing. They point directly into the DDL source code being parsed so they cannot be changed. The methods that can be used to validate a generic tag are:</p>

<ul>
<li><code>bool DDLParser::Str::operator==( const DDLParser::Str::Str& other ) const</code></li>
<li><code>bool DDLParser::Str::operator==( const char* other ) const</code></li>
<li><code>const char* DDLParser::Str::GetChars() const</code></li>
<li><code>unsigned int DDLParser::Str::GetLength() const</code></li>
<li><code>uint32_t DDLParser::Str::GetHash() const</code></li>
</ul>

<hr/><h1>DDLParser::TagSet</h1>

<p>When one of the callbacks is called to validate a generic tag, a DDLParser::TagSet is provided to allow for keeping a record of which tags have already been defined and i.e. disallow duplicates. The methods that can be used during validation are:</p>

<ul>
<li><code>bool DDLParser::TagSet::Insert( uint32_t element )</code></li>
<li><code>bool DDLParser::TagSet::Exists( uint32_t element )</code></li>
</ul>

<p>Note that the tag's name hash (as returned by DDLParser::GenericTag::GetNameHash) should be used with tag sets.</p>

<hr/><h1>DDL Grammar</h1>

<p>The language permits the declaration of any number of structures, bitfields and selects. At least one such declaration must exist in a valid DDL file.</p>

<code><pre>grammar ddl<span class="operator">;</span>
ddl<span class="operator">
  :</span><span class="operator"> (</span> typedef<span class="operator"> |</span> struct<span class="operator"> |</span> bitfield<span class="operator"> |</span> select<span class="operator"> )</span><span class="operator">+</span><span class="operator">
  ;</span></pre></code>

<p>A typedef is an alias to a data type, array type and a set of tags. After defining a typedef it can be used to declare fields, which will have everything that was defined in the typedef.</p>

<code><pre>typedef<span class="operator">
  :</span><span class="string"> 'typedef'</span> data_type<span class="operator"> (</span><span class="string"> '['</span><span class="operator"> (</span> expression<span class="operator"> )</span><span class="operator">?</span><span class="string"> ']'</span><span class="operator"> |</span><span class="string"> '{'</span> data_type<span class="string"> '}'</span><span class="operator"> )</span><span class="operator">?</span><span class="operator"> (</span><span class="string"> ','</span> typedef_info<span class="operator"> )</span><span class="operator">*</span><span class="operator">
  ;</span>
typedef_info<span class="operator">
  :</span><span class="string"> 'author'</span><span class="string"> '('</span> LITERAL<span class="string"> ')'</span><span class="operator">
  |</span><span class="string"> 'description'</span><span class="string"> '('</span> LITERAL<span class="string"> ')'</span><span class="operator">
  |</span><span class="string"> 'label'</span><span class="string"> '('</span> LITERAL<span class="string"> ')'</span><span class="operator">
  |</span><span class="string"> 'uirender'</span><span class="string"> '('</span> LITERAL<span class="string"> ')'</span><span class="operator">
  |</span><span class="string"> 'callback'</span><span class="string"> '('</span> LITERAL<span class="string"> ')'</span><span class="operator">
  |</span><span class="string"> 'key'</span><span class="string"> '('</span> LITERAL<span class="string"> ')'</span><span class="operator">
  |</span><span class="string"> 'units'</span><span class="string"> '('</span> LITERAL<span class="string"> ')'</span><span class="operator">
  |</span><span class="string"> 'extensions'</span><span class="string"> '('</span> LITERAL<span class="operator"> (</span><span class="string"> ','</span> LITERAL<span class="operator"> )</span><span class="operator">*</span><span class="string"> ')'</span><span class="operator">
  |</span><span class="string"> 'vaulthints'</span><span class="string"> '('</span> LITERAL<span class="operator"> (</span><span class="string"> ','</span> LITERAL<span class="operator"> )</span><span class="operator">*</span><span class="string"> ')'</span><span class="operator">
  |</span><span class="string"> 'uirange'</span><span class="string"> '('</span> expression<span class="string"> ','</span> expression<span class="operator"> (</span><span class="string"> ','</span> expression<span class="string"> ','</span> expression<span class="operator"> (</span><span class="string"> ','</span> expression<span class="operator"> )</span><span class="operator">?</span><span class="operator"> )</span><span class="operator">?</span><span class="string"> ')'</span><span class="operator">
  |</span> generic_tag<span class="operator">
  ;</span></pre></code>

<p>A structure begins with the <code>struct</code> keyword and with the structure name, an identifier. After the name the author, description, and label of the structure can be specified but they're not mandatory. The fields can then be specified enclosed by curly braces.</p>

<code><pre>struct<span class="operator">
  :</span><span class="string"> 'struct'</span> ID<span class="operator"> (</span><span class="string"> ','</span> struct_info<span class="operator"> )</span><span class="operator">*</span><span class="string"> '{'</span> field<span class="operator">*</span><span class="string"> '}'</span><span class="operator">
  ;</span></pre></code>

<p><code>struct_info</code> allows for additional information about aggregates, namely its author, description and label. Labels are used to name UI controls, and descriptions can be used as tips for these controls. Although the grammar allows for repetitions, the parser checks for duplicates and errors accordingly.</p>

<p>The structure can also inherit fields from a parent structure, specified by the <code>base</code> tag.</p>

<code><pre>struct_info<span class="operator">
  :</span><span class="string"> 'author'</span><span class="string"> '('</span> LITERAL<span class="string"> ')'</span><span class="operator">
  |</span><span class="string"> 'description'</span><span class="string"> '('</span> LITERAL<span class="string"> ')'</span><span class="operator">
  |</span><span class="string"> 'label'</span><span class="string"> '('</span> LITERAL<span class="string"> ')'</span><span class="operator">
  |</span><span class="string"> 'base'</span><span class="string"> '('</span> ID<span class="string"> ')'</span><span class="operator">
  |</span><span class="string"> 'uirender'</span><span class="string"> '('</span> LITERAL<span class="string"> ')'</span><span class="operator">
  |</span><span class="string"> 'version'</span><span class="string"> '('</span> LITERAL<span class="string"> ')'</span><span class="operator">
  |</span><span class="string"> 'callback'</span><span class="string"> '('</span> LITERAL<span class="string"> ')'</span><span class="operator">
  |</span><span class="string"> 'key'</span><span class="string"> '('</span> LITERAL<span class="string"> ')'</span><span class="operator">
  |</span> generic_tag<span class="operator">
  ;</span>
generic_tag<span class="operator">:</span><span class="operator">
  :</span><span class="string"> 'tag'</span><span class="string"> '('</span> ID<span class="operator"> (</span><span class="string"> ','</span> expression<span class="operator"> )</span><span class="operator">*</span><span class="string"> ')'</span><span class="operator">
  ;</span></pre></code>

<p>A field declaration begins with the field type of a typedef identifier. After that the field name (an identifier), is parsed and additional information about the field can be specified.</p>

<code><pre>field<span class="operator">
  :</span><span class="operator"> (</span> field_type<span class="operator"> |</span> ID<span class="operator"> )</span> ID<span class="operator"> (</span><span class="string"> ','</span> field_info<span class="operator"> )</span><span class="operator">*</span><span class="string"> ';'</span><span class="operator">
  ;</span></pre></code>

<p>The field type is a data type. If the data type is followed by a opening square brace, it denotes that the field is an array. If an integer expression is provided within the braces the array has a fixed size, otherwise the array is dynamic and elements can added to/removed from it at runtime (depending on the code that is generated). If the data type is followed by opening curly brace, it denotes a hashmap mapping values of the data type inside the curly braces to values of the data type of the field.</p>

<code><pre>field_type<span class="operator">
  :</span> data_type<span class="operator"> (</span><span class="string"> '['</span><span class="operator"> (</span> expression<span class="operator"> )</span><span class="operator">?</span><span class="string"> ']'</span><span class="operator"> |</span><span class="string"> '{'</span> data_type<span class="string"> '}'</span><span class="operator"> )</span><span class="operator">?</span><span class="operator">
  ;</span></pre></code>

<p>The field data type can be one of the native types or a custom type. The native types are signed and unsigned integers with 8, 16, 32 or 64 bits, float, double, string, file, boolean, tuid and json. A custom type is just an identifier denoting a select, bitfield or structure.</p>

<code><pre>data_type<span class="operator">
  :</span><span class="string"> 'uint8_t'</span><span class="operator">  |</span><span class="string"> 'u8'</span><span class="operator">
  |</span><span class="string"> 'uint16_t'</span><span class="operator"> |</span><span class="string"> 'u16'</span><span class="operator">
  |</span><span class="string"> 'uint32_t'</span><span class="operator"> |</span><span class="string"> 'u32'</span><span class="operator">
  |</span><span class="string"> 'uint64_t'</span><span class="operator"> |</span><span class="string"> 'u64'</span><span class="operator">
  |</span><span class="string"> 'int8_t'</span><span class="operator">   |</span><span class="string"> 'i8'</span><span class="operator">
  |</span><span class="string"> 'int16_t'</span><span class="operator">  |</span><span class="string"> 'i16'</span><span class="operator">
  |</span><span class="string"> 'int32_t'</span><span class="operator">  |</span><span class="string"> 'i32'</span><span class="operator">
  |</span><span class="string"> 'int64_t'</span><span class="operator">  |</span><span class="string"> 'i64'</span><span class="operator">
  |</span><span class="string"> 'float'</span><span class="operator">    |</span><span class="string"> 'f32'</span><span class="operator">
  |</span><span class="string"> 'double'</span><span class="operator">   |</span><span class="string"> 'f64'</span><span class="operator">
  |</span><span class="string"> 'boolean'</span><span class="operator">  |</span><span class="string"> 'bool'</span><span class="operator">
  |</span><span class="string"> 'string'</span><span class="operator">
  |</span><span class="string"> 'file'</span><span class="operator">
  |</span><span class="string"> 'tuid'</span><span class="operator">
  |</span><span class="string"> 'json'</span><span class="operator">
  |</span> ID<span class="operator">
  ;</span></pre></code>

<p><code>field_info</code> allows for additional information about fields, namely its author, description, label and a default value. The default value is the value used to initialize the field.</p>

<code><pre>field_info<span class="operator">
  :</span><span class="string"> 'author'</span><span class="string"> '('</span> LITERAL<span class="string"> ')'</span><span class="operator">
  |</span><span class="string"> 'description'</span><span class="string"> '('</span> LITERAL<span class="string"> ')'</span><span class="operator">
  |</span><span class="string"> 'label'</span><span class="string"> '('</span> LITERAL<span class="string"> ')'</span><span class="operator">
  |</span><span class="string"> 'value'</span><span class="string"> '('</span> default_value<span class="string"> ')'</span><span class="operator">
  |</span><span class="string"> 'extensions'</span><span class="string"> '('</span> LITERAL<span class="operator"> (</span><span class="string"> ','</span> LITERAL<span class="operator"> )</span><span class="operator">*</span><span class="string"> ')'</span><span class="operator">
  |</span><span class="string"> 'vaulthints'</span><span class="string"> '('</span> LITERAL<span class="operator"> (</span><span class="string"> ','</span> LITERAL<span class="operator"> )</span><span class="operator">*</span><span class="string"> ')'</span><span class="operator">
  |</span><span class="string"> 'uirange'</span><span class="string"> '('</span> expression<span class="string"> ','</span> expression<span class="operator"> (</span><span class="string"> ','</span> expression<span class="string"> ','</span> expression<span class="operator"> (</span><span class="string"> ','</span> expression<span class="operator"> )</span><span class="operator">?</span><span class="operator"> )</span><span class="operator">?</span><span class="string"> ')'</span><span class="operator">
  |</span><span class="string"> 'uirender'</span><span class="string"> '('</span> LITERAL<span class="string"> ')'</span><span class="operator">
  |</span><span class="string"> 'parallel'</span><span class="string"> '('</span> ID<span class="string"> ')'</span><span class="operator">
  |</span><span class="string"> 'units'</span><span class="string"> '('</span> LITERAL<span class="string"> ')'</span><span class="operator">
  |</span> generic_tag<span class="operator">
  ;</span></pre></code>

<p>The <code>default_value</code> is a complex rule, and which option is taken depends on the context. In other words, it's a parser decision depending on what it was parsing.</p>

<code><pre>default_value<span class="comment">
  /* 1 */</span><span class="operator"> :</span> native_value<span class="comment">
  /* 2 */</span><span class="operator"> |</span> select_value<span class="comment">
  /* 3 */</span><span class="operator"> |</span> bitfield_value<span class="comment">
  /* 4 */</span><span class="operator"> |</span> struct_value<span class="comment">
  /* 5 */</span><span class="operator"> |</span><span class="string"> '{'</span> native_value<span class="operator">   (</span><span class="string"> ','</span> native_value<span class="operator">   )</span><span class="operator">*</span><span class="string"> '}'</span><span class="comment">
  /* 6 */</span><span class="operator"> |</span><span class="string"> '{'</span> select_value<span class="operator">   (</span><span class="string"> ','</span> select_value<span class="operator">   )</span><span class="operator">*</span><span class="string"> '}'</span><span class="comment">
  /* 7 */</span><span class="operator"> |</span><span class="string"> '{'</span> bitfield_value<span class="operator"> (</span><span class="string"> ','</span> bitfield_value<span class="operator"> )</span><span class="operator">*</span><span class="string"> '}'</span><span class="comment">
  /* 8 */</span><span class="operator"> |</span><span class="string"> '{'</span> struct_value<span class="operator">   (</span><span class="string"> ','</span> struct_value<span class="operator">   )</span><span class="operator">*</span><span class="string"> '}'</span><span class="operator">
  ;</span>
native_value<span class="operator">
  :</span> expression<span class="operator">
  ;</span>
select_value<span class="operator">
  :</span> ID<span class="operator">
  ;</span>
bitfield_value<span class="operator">
  :</span> ID<span class="operator"> (</span><span class="string"> '|'</span> ID<span class="operator"> )</span><span class="operator">*</span><span class="operator">
  ;</span>
struct_value<span class="operator">
  :</span><span class="string"> '{'</span> ID<span class="string"> '='</span> default_value<span class="operator"> (</span><span class="string"> ','</span> ID<span class="string"> '='</span> default_value<span class="operator"> )</span><span class="operator">*</span><span class="string"> '}'</span><span class="operator">
  ;</span></pre></code>

<ul>
<li>Option #1 is taken when the field is of a native type and is not an array.</li>
<li>Option #2 is taken when the field is of a select type and is not an array.</li>
<li>Option #3 is taken when the field is of a bitfield type and is not an array.</li>
<li>Option #4 is taken when the field is of a structure type and is not an array.</li>
<li>Options #5 to #8 correspond to options #1 to #4 but are for arrays of native, select, bitfield and structure values.</li>
</ul>

<p>A bitfield is declared with the <code>bitfield</code> keyword followed by its name, an identifier, which may be followed by additional information. Its flags are declared inside enclosing braces.</p>

<code><pre>bitfield<span class="operator">
  :</span><span class="string"> 'bitfield'</span> ID<span class="operator"> (</span><span class="string"> ','</span> bitfield_info<span class="operator"> )</span><span class="operator">*</span><span class="string"> '{'</span> flag<span class="operator">+</span><span class="string"> '}'</span><span class="operator">
  ;</span>
bitfield_info<span class="operator">
  :</span><span class="string"> 'author'</span><span class="string"> '('</span> LITERAL<span class="string"> ')'</span><span class="operator">
  |</span><span class="string"> 'description'</span><span class="string"> '('</span> LITERAL<span class="string"> ')'</span><span class="operator">
  |</span><span class="string"> 'label'</span><span class="string"> '('</span> LITERAL<span class="string"> ')'</span><span class="operator">
  |</span> generic_tag<span class="operator">
  ;</span></pre></code>

<p>Declarations of bitfield flags begin with an identifier which is its name, followed by additional flag information.</p>

<code><pre>flag<span class="operator">
  :</span> ID<span class="operator"> (</span><span class="string"> ','</span> flag_info<span class="operator"> )</span><span class="operator">*</span><span class="string"> ';'</span><span class="operator">
  ;</span></pre></code>

<p>Besides author, description and label, a flag can be specified as the default flag for the bitfield. Flags can also be declared as empty, meaning that their value is zero. If a value is specified, the flag is a set containing all listed flags.</p>

<code><pre>flag_info<span class="operator">
  :</span><span class="string"> 'author'</span><span class="string"> '('</span> LITERAL<span class="string"> ')'</span><span class="operator">
  |</span><span class="string"> 'description'</span><span class="string"> '('</span> LITERAL<span class="string"> ')'</span><span class="operator">
  |</span><span class="string"> 'label'</span><span class="string"> '('</span> LITERAL<span class="string"> ')'</span><span class="operator">
  |</span><span class="string"> 'default'</span><span class="operator">
  |</span><span class="string"> 'value'</span><span class="string"> '('</span> ID<span class="operator"> (</span><span class="string"> '|'</span> ID<span class="operator"> )</span><span class="operator">*</span><span class="string"> ')'</span><span class="operator">
  |</span><span class="string"> 'empty'</span><span class="operator">
  |</span> generic_tag<span class="operator">
  ;</span></pre></code>

<p>A select is declared in the same way of a bitfield.</p>

<code><pre>select<span class="operator">
  :</span><span class="string"> 'select'</span> ID<span class="operator"> (</span><span class="string"> ','</span> select_info<span class="operator"> )</span><span class="operator">*</span><span class="string"> '{'</span> item<span class="operator">+</span><span class="string"> '}'</span><span class="operator">
  ;</span>
select_info<span class="operator">
  :</span><span class="string"> 'author'</span><span class="string"> '('</span> LITERAL<span class="string"> ')'</span><span class="operator">
  |</span><span class="string"> 'description'</span><span class="string"> '('</span> LITERAL<span class="string"> ')'</span><span class="operator">
  |</span><span class="string"> 'label'</span><span class="string"> '('</span> LITERAL<span class="string"> ')'</span><span class="operator">
  |</span> generic_tag<span class="operator">
  ;</span></pre></code>

<p>A select item has an implicit type of <code>uint32_t</code> so it's not possible to define a type for it. Its declaration begin with an identifier which is its name, followed by additional information. The value of a select item is the DDLParser::StringCrc32 of its name so it's not possible to define a value for it.</p>

<p>The item defined as the default item is used to initialize the default value of structure fields having the select type. As with bitfields, this default can be overridden by using the <code>value</code> tag in the field declaration. If no item is declared as the default, the first item declared in the select will be the default.</p>

<code><pre>item<span class="operator">
  :</span> ID<span class="operator"> (</span><span class="string"> ','</span> item_info<span class="operator"> )</span><span class="operator">*</span><span class="string"> ';'</span><span class="operator">
  ;</span>
item_info<span class="operator">
  :</span><span class="string"> 'author'</span><span class="string"> '('</span> LITERAL<span class="string"> ')'</span><span class="operator">
  |</span><span class="string"> 'description'</span><span class="string"> '('</span> LITERAL<span class="string"> ')'</span><span class="operator">
  |</span><span class="string"> 'label'</span><span class="string"> '('</span> LITERAL<span class="string"> ')'</span><span class="operator">
  |</span><span class="string"> 'default'</span><span class="operator">
  |</span> generic_tag<span class="operator">
  ;</span></pre></code>

<p>The expression rule parses any valid C-like expression. It's defined as the ternary operator.</p>

<code><pre>expression<span class="operator">
  :</span> ternary<span class="operator">
  ;</span></pre></code>

<p>The ternary operator is a <code>logic_or</code> expression optionally followed by a <code>?</code> and two expressions. If the logic_or expression is true (different from zero), the value of the ternary operator is the result of the first expression. If it's false, the value of the ternary operator is the result of the second expression. If <code>?</code> is not present in the expression, the value of the ternary operator is the value of the <code>logic_or</code> expression.</p>

<code><pre>ternary<span class="operator">
  :</span> logic_or<span class="operator"> (</span><span class="string"> '?'</span> expression<span class="string"> ':'</span> expression<span class="operator"> )</span><span class="operator">?</span><span class="operator">
  ;</span></pre></code>

<p>The <code>logic_or</code> expression is the value of a <code>logic_and</code> expression, optionally or'ed with other <code>logic_and</code> expressions.</p>

<code><pre>logic_or<span class="operator">
  :</span> logic_and<span class="operator"> (</span><span class="string"> '||'</span> logic_and<span class="operator"> )</span><span class="operator">*</span><span class="operator">
  ;</span></pre></code>

<p>The <code>logic_and</code> expression is the value of an <code>arithmetic_or</code> expression, optionally and'ed with other <code>arithmetic_or</code> expressions.</p>

<code><pre>logic_and<span class="operator">
  :</span> arithmetic_or<span class="operator"> (</span><span class="string"> '&&'</span> arithmetic_or<span class="operator"> )</span><span class="operator">*</span><span class="operator">
  ;</span></pre></code>

<p>The <code>arithmetic_or</code> expression is the value of an <code>arithmetic_xor</code> expression, optionally bitwise-or'ed with other <code>arithmetic_xor</code> expressions.</p>

<code><pre>arithmetic_or<span class="operator">
  :</span> arithmetic_xor<span class="operator"> (</span><span class="string"> '|'</span> arithmetic_xor<span class="operator"> )</span><span class="operator">*</span><span class="operator">
  ;</span></pre></code>

<p>The <code>arithmetic_xor</code> expression is the value of an <code>arithmetic_and</code> expression, optionally bitwise-xor'ed with other <code>arithmetic_and</code> expressions.</p>

<code><pre>arithmetic_xor<span class="operator">
  :</span> arithmetic_and<span class="operator"> (</span><span class="string"> '^'</span> arithmetic_and<span class="operator"> )</span><span class="operator">*</span><span class="operator">
  ;</span></pre></code>

<p>The <code>arithmetic_and</code> expression is the value of an <code>equal</code> expression, optionally bitwise-and'ed with other <code>equal</code> expressions.</p>

<code><pre>arithmetic_and<span class="operator">
  :</span> equal<span class="operator"> (</span><span class="string"> '&'</span> equal<span class="operator"> )</span><span class="operator">*</span><span class="operator">
  ;</span></pre></code>

<p>The <code>equal</code> expression is the value of a <code>conditional</code> expression, optionally compared for equality or inequality with other <code>conditional</code> expressions. It's thus possible to write <code>a > b == c > d</code> meaning <code>a > b</code> and <code>c > d</code> are both either false or true, and <code>a > b != c > d</code> meaning <code>a > b</code> is true and <code>c > d</code> is false or vice-versa.</p>

<code><pre>equal<span class="operator">
  :</span> conditional<span class="operator"> (</span><span class="operator"> (</span><span class="string"> '=='</span><span class="operator"> |</span><span class="string"> '!='</span><span class="operator"> )</span> conditional<span class="operator"> )</span><span class="operator">*</span><span class="operator">
  ;</span></pre></code>

<p>The <code>conditional</code> expression is the value of a <code>shift</code> expression, optionally compared with other <code>shift</code> expressions with one of the operators <code><</code>, <code>></code>, <code><=</code> or <code>>=</code>.</p>

<code><pre>conditional<span class="operator">
  :</span> shift<span class="operator"> (</span><span class="operator"> (</span><span class="string"> '<'</span><span class="operator"> |</span><span class="string"> '>'</span><span class="operator"> |</span><span class="string"> '<='</span><span class="operator"> |</span><span class="string"> '>='</span><span class="operator"> )</span> shift<span class="operator"> )</span><span class="operator">*</span><span class="operator">
  ;</span></pre></code>

<p>The <code>shift</code> expression is the value of a <code>term</code> expression, optionally shifted left or right by other <code>term</code> expressions.</p>

<code><pre>shift<span class="operator">
  :</span> term<span class="operator"> (</span><span class="operator"> (</span><span class="string"> '<<'</span><span class="operator"> |</span><span class="string"> '>>'</span><span class="operator"> )</span> term<span class="operator"> )</span><span class="operator">*</span><span class="operator">
  ;</span></pre></code>

<p>The <code>term</code> expression is the value of a <code>factor</code> expression, optionally added to or subtracted from other <code>factor</code> expressions.</p>

<code><pre>term<span class="operator">
  :</span> factor<span class="operator"> (</span><span class="operator"> (</span><span class="string"> '+'</span><span class="operator"> |</span><span class="string"> '-'</span><span class="operator"> )</span> factor<span class="operator"> )</span><span class="operator">*</span><span class="operator">
  ;</span></pre></code>

<p>The factor expression is the value of an <code>unary</code> expression, optionally multiplied by, divided by, mod'ed by other <code>unary</code> expressions.</p>

<code><pre>factor<span class="operator">
  :</span> unary<span class="operator"> (</span><span class="operator"> (</span><span class="string"> '*'</span><span class="operator"> |</span><span class="string"> '/'</span><span class="operator"> |</span><span class="string"> '%'</span><span class="operator"> )</span> unary<span class="operator"> )</span><span class="operator">*</span><span class="operator">
  ;</span></pre></code>

<p>The <code>unary</code> expression is either the value of a <code>terminal</code> or the value of another <code>unary</code> changed by the unary plus, minus, negate or not operators.</p>

<code><pre>unary<span class="operator">
  :</span><span class="operator"> (</span><span class="string"> '+'</span><span class="operator"> |</span><span class="string"> '-'</span><span class="operator"> |</span><span class="string"> '~'</span><span class="operator"> |</span><span class="string"> '!'</span><span class="operator"> )</span> unary<span class="operator">
  |</span> terminal<span class="operator">
  ;</span></pre></code>

<p>The terminal expression is an octal, hexadecimal, decimal or real (in base 10) number, a string, the constants <code>true</code>, <code>false</code>, <code>pi</code> or <code>e</code>, or another expression enclosed in parenthesis.</p>

<code><pre>terminal<span class="operator">
  :</span> OCTAL<span class="operator"> |</span> BINARY<span class="operator"> |</span> HEXADECIMAL<span class="operator"> |</span> DECIMAL<span class="operator"> |</span> REAL<span class="operator"> |</span> LITERAL<span class="operator">
  |</span><span class="string"> 'true'</span><span class="operator"> |</span><span class="string"> 'false'</span><span class="operator">
  |</span><span class="string"> 'pi'</span><span class="operator"> |</span><span class="string"> 'e'</span><span class="operator">
  |</span><span class="string"> '('</span> expression<span class="string"> ')'</span><span class="operator">
  ;</span></pre></code>

<p>Octal constants must begin with a 0, and can only have digits from 0 to 7.</p>

<code><pre>OCTAL<span class="operator">
  :</span><span class="string"> '0'</span><span class="operator"> (</span><span class="string"> '0'</span><span class="operator"> .</span><span class="operator">.</span><span class="string"> '7'</span><span class="operator"> )</span><span class="operator">+</span><span class="operator">
  ;</span></pre></code>

<p>Binary constants must begin with <code>0b</code>, and can only have digits 0 and 1.</p>

<code><pre>BINARY<span class="operator">
  :</span><span class="string"> '0b'</span><span class="operator"> (</span><span class="string"> '0'</span><span class="operator"> |</span><span class="string"> '1'</span><span class="operator"> )</span><span class="operator">+</span><span class="operator">
  ;</span></pre></code>

<p>Hexadecimal constants must begin with <code>0x</code>, and can have digits from 0 to 9 and from A to F (case insensitive).</p>

<code><pre>HEXADECIMAL<span class="operator">
  :</span><span class="string"> '0x'</span><span class="operator"> (</span> HEX_DIGIT<span class="operator"> )</span><span class="operator">+</span><span class="operator">
  ;</span>
HEX_DIGIT<span class="operator">:</span><span class="operator">
  :</span><span class="string"> '0'</span><span class="operator"> .</span><span class="operator">.</span><span class="string"> '9'</span><span class="operator">
  |</span><span class="string"> 'a'</span><span class="operator"> .</span><span class="operator">.</span><span class="string"> 'f'</span><span class="operator">
  |</span><span class="string"> 'A'</span><span class="operator"> .</span><span class="operator">.</span><span class="string"> 'f'</span><span class="operator">
  ;</span></pre></code>

  
<p>Decimal numbers can only have digits from 0 to 9. In the lexical analyser, if a number starts with 0 it's considered to be an octal constant.</p>

<code><pre>DECIMAL<span class="operator">
  :</span><span class="operator"> (</span><span class="string"> '0'</span><span class="operator"> .</span><span class="operator">.</span><span class="string"> '9'</span><span class="operator"> )</span><span class="operator">+</span><span class="operator">
  ;</span></pre></code>

<p>Real numbers are decimal numbers with an optional decimal period followed by another decimal number. They can have an optional exponent (an <code>e</code> or <code>E</code>) followed by the decimal exponent value which can be signed, and optionally ended with an <code>f</code>. If the real number does not have a decimal period and neither an exponent, it must end with an <code>f</code> otherwise it will be analyzed as a decimal number. Note that this is different from what is expected from C.</p>

<code><pre>REAL<span class="operator">
  :</span> DECIMAL<span class="operator"> (</span><span class="string"> '.'</span> DECIMAL<span class="operator"> )</span><span class="operator">?</span><span class="operator"> (</span><span class="operator"> (</span><span class="string"> 'e'</span><span class="operator"> |</span><span class="string"> 'E'</span><span class="operator"> )</span><span class="operator"> (</span><span class="string"> '+'</span><span class="operator"> |</span><span class="string"> '-'</span><span class="operator"> )</span> DECIMAL<span class="operator"> )</span><span class="operator">?</span><span class="string"> 'f'</span><span class="operator">?</span><span class="operator">
  ;</span></pre></code>

<p>Identifiers are case sensitive sequences of upper case letters, lower case letters, decimal digits and underscores. They cannot begin with a decimal digit.</p>

<code><pre>ID<span class="operator">
  :</span><span class="operator"> (</span><span class="string"> 'a'</span><span class="operator"> .</span><span class="operator">.</span><span class="string"> 'z'</span><span class="operator"> |</span><span class="string"> 'A'</span><span class="operator"> .</span><span class="operator">.</span><span class="string"> 'Z'</span><span class="operator"> |</span><span class="string"> '_'</span><span class="operator"> )</span><span class="operator"> (</span><span class="string"> 'a'</span><span class="operator"> .</span><span class="operator">.</span><span class="string"> 'z'</span><span class="operator"> |</span><span class="string"> 'A'</span><span class="operator"> .</span><span class="operator">.</span><span class="string"> 'Z'</span><span class="operator"> |</span><span class="string"> '_'</span><span class="operator"> |</span><span class="string"> '0'</span><span class="operator"> .</span><span class="operator">.</span><span class="string"> '9'</span><span class="operator"> )</span><span class="operator">*</span><span class="operator">
  ;</span></pre></code>

<p>Literals are string constants which are sequences of any characters except the percent sign (which is the beginning of an escape sequence), the double quote (which marks the end of the string) and line feed. Strings are enclosed in double quotes.</p>

<code><pre>LITERAL<span class="operator">
  :</span><span class="string"> '"'</span><span class="operator"> (</span><span class="string"> '%'</span> HEX_DIGIT HEX_DIGIT<span class="operator"> |</span><span class="operator"> ~</span><span class="operator">(</span><span class="string"> '%'</span><span class="operator"> |</span><span class="string"> '"'</span><span class="operator"> )</span><span class="operator"> )</span><span class="operator">*</span><span class="string"> '"'</span><span class="operator">
  ;</span></pre></code>

<p>Escape sequences always start with a <code>%</code>, and must be followed by two hexadecimal digits. These three characters will be converted to one character in the resulting literal, and this character will have the code specified by the two hexadecimal digits.</p>

<p>Literals are codepage agnostic, so the meaning of characters with codes outside of the [0, 127] range are platform dependent.</p>

<hr/><h1>License</h1>

<p>Copyright (c) 2012, Insomniac Games<br/>
All rights reserved.</p>

<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>

<ul>
<li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li>
</ul>

<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>


</body></html>659