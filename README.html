<html>
<head>
  <style type="text/css">
    h1 { font-size: 14pt; font-weight: bold; }
    h2 { font-size: 12pt; font-weight: bold; }
    p { margin-left:2em; }
    pre { margin-left: 2.5em; }
    ul { margin-left: 0.5em; }
  </style>
  <meta name="generator" content="C++2HTML by Jasper Bedaux" />
  <style type="text/css">
    .comment { color: #999999; font-style: italic; }
    .pre { color: #000099; }
    .string { color: #009900; }
    .char { color: #009900; }
    .float { color: #996600; }
    .int { color: #999900; }
    .bool { color: #000000; font-weight: bold; }
    .type { color: #FF6633; }
    .flow { color: #FF0000; }
    .keyword { color: #990000; }
    .operator { color: #663300; font-weight: bold; }
  </style>
</head>
<body>

<h1><a name="DDL Specification">DDL Specification</a></h1>

<p>DDL files can contain three constructs: selects, bitfields and structures. All constructs must have a name, and they can have an author, a description and a label assigned to them. These fields can be used by tools when rendering the constructs as UI elements.</p>

<p>There is a annotated DDL grammar at the end of this document for further reference.</p>

<hr/><h1><a name="Selects">Selects</a></h2>

<p>A select is just a list of options much like an C enum. They represent exclusive values, like a drop-down where just one value can be selected. But unlike C enums, numeric values cannot be assigned to select fields; their values are just the hash of their names. This way new fields can be added without constraints while maintaining compatibility with cold that uses the select.</p>

<p>Each select item can have an author, a description and a label.</p>

<h2>Example</h2>

<code><pre><span class="keyword">select</span> Weapon<span class="operator">,</span><span class="keyword"> author</span><span class="operator">(</span><span class="string"> "Andre de Leiradella"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword"> description</span><span class="operator">(</span><span class="string"> "Weapons available to the player"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword"> label</span><span class="operator">(</span><span class="string"> "Weapon"</span><span class="operator"> )</span><span class="operator">
{</span>
  kFist<span class="operator">,</span><span class="keyword">           description</span><span class="operator">(</span><span class="string"> "Bare hands"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword">               label</span><span class="operator">(</span><span class="string"> "Fist"</span><span class="operator"> )</span><span class="operator">;</span>
  kChainsaw<span class="operator">,</span><span class="keyword">       description</span><span class="operator">(</span><span class="string"> "A la Chainsaw Massacre"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword">   label</span><span class="operator">(</span><span class="string"> "Chainsaw"</span><span class="operator"> )</span><span class="operator">;</span>
  kPistol<span class="operator">,</span><span class="keyword">         description</span><span class="operator">(</span><span class="string"> "Simple pistol"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword">            label</span><span class="operator">(</span><span class="string"> "Pistol"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword"> default</span><span class="operator">;</span>
  kShotgun<span class="operator">,</span><span class="keyword">        description</span><span class="operator">(</span><span class="string"> "A single-barrel shotgun"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword">  label</span><span class="operator">(</span><span class="string"> "Shotgun"</span><span class="operator"> )</span><span class="operator">;</span>
  kChaingun<span class="operator">,</span><span class="keyword">       description</span><span class="operator">(</span><span class="string"> "A machine gun"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword">            label</span><span class="operator">(</span><span class="string"> "Chaingun"</span><span class="operator"> )</span><span class="operator">;</span>
  kRocketLauncher<span class="operator">,</span><span class="keyword"> description</span><span class="operator">(</span><span class="string"> "Portable rocket launcher"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword"> label</span><span class="operator">(</span><span class="string"> "Rocket launcher"</span><span class="operator"> )</span><span class="operator">;</span>
  kPlasmaGun<span class="operator">,</span><span class="keyword">      description</span><span class="operator">(</span><span class="string"> "Plasma gun"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword">               label</span><span class="operator">(</span><span class="string"> "Plasma gun"</span><span class="operator"> )</span><span class="operator">;</span>
  kBFG9000<span class="operator">,</span><span class="keyword">        description</span><span class="operator">(</span><span class="string"> "*The* BFG 9000"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword">           label</span><span class="operator">(</span><span class="string"> "BFG 9000"</span><span class="operator"> )</span><span class="operator">;</span><span class="operator">
}</span></pre></code>

<p>An item can be marked as default (see item <code>kPistol</code>) and it will be the item used in fields declared with the select type that don't have an explicit value to override the default.</p>

<hr/><h1><a name="Bitfields">Bitfields</a></h1>

<p><a href="#Bitfields">Bitfields</a> represent a set of related flags. Their flags can be or'ed to form the value of another flag. <a href="#Bitfields">Bitfields</a> should be used where more than one value can be selected, like a checkbox group.</p>

<p>As with select items, each bitfield flag can have an author, a description and a label.</p>

<h2>Example</h2>

<code><pre><span class="keyword">bitfield</span> Powerup<span class="operator">,</span><span class="keyword"> author</span><span class="operator">(</span><span class="string"> "Andre de Leiradella"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword"> description</span><span class="operator">(</span><span class="string"> "Powerup pickups"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword"> label</span><span class="operator">(</span><span class="string"> "Powerup"</span><span class="operator"> )</span><span class="operator">
{</span>
  kNone<span class="operator">,</span><span class="keyword">                description</span><span class="operator">(</span><span class="string"> "Help me!"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword"> empty</span><span class="operator">;</span>
  kRadiationSuit<span class="operator">,</span><span class="keyword">       description</span><span class="operator">(</span><span class="string"> "Makes the player immune to radiation for a limited time"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword">             label</span><span class="operator">(</span><span class="string"> "Radiation suit"</span><span class="operator"> )</span><span class="operator">;</span>
  kPartialInvisibility<span class="operator">,</span><span class="keyword"> description</span><span class="operator">(</span><span class="string"> "Makes the player almost invisible to enemies for a limited time"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword">     label</span><span class="operator">(</span><span class="string"> "Partial invisibility"</span><span class="operator"> )</span><span class="operator">;</span>
  kInvulnerability<span class="operator">,</span><span class="keyword">     description</span><span class="operator">(</span><span class="string"> "Makes the player invulnerable for a limited time"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword">                    label</span><span class="operator">(</span><span class="string"> "Invulnerability"</span><span class="operator"> )</span><span class="operator">;</span>
  kComputerMap<span class="operator">,</span><span class="keyword">         description</span><span class="operator">(</span><span class="string"> "Gives the complete map of the level to the player"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword">                   label</span><span class="operator">(</span><span class="string"> "Computer map"</span><span class="operator"> )</span><span class="operator">;</span>
  kLightVisor<span class="operator">,</span><span class="keyword">          description</span><span class="operator">(</span><span class="string"> "Allows the player to see in the dark for a limited time"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword">             label</span><span class="operator">(</span><span class="string"> "Light visor"</span><span class="operator"> )</span><span class="operator">;</span>
  kBerserk<span class="operator">,</span><span class="keyword">             description</span><span class="operator">(</span><span class="string"> "Gives the player the ability to quickly kill enemies with his fists"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword"> label</span><span class="operator">(</span><span class="string"> "Berserk"</span><span class="operator"> )</span><span class="operator">;</span>
  kAll<span class="operator">,</span><span class="keyword">                 value</span><span class="operator">(</span> kRadiationSuit<span class="operator"> |</span> kPartialInvisibility<span class="operator"> |</span> kInvulnerability<span class="operator"> |</span> kComputerMap<span class="operator"> |</span> kLightVisor<span class="operator"> |</span> kBerserk<span class="operator"> )</span><span class="operator">;</span><span class="operator">
}</span></pre></code>

<p>Flags without a value will get an unique bit index that can be queried at runtime. Flags can be marked as default. If there isn't a default flag in the bitfield the empty flag will be used, or the first declared flag will be used if there isn't an empty flag. To get a zeroed flag, tag it with <code>empty</code> like the <code>kNone</code> flag above.</p>

<hr/><h1><a name="Structures">Structures</a></h1>

<p>While selects and bitfields only define custom types and take no memory, structures are aggregates of fields which actually take up memory to hold their fields' values.</p>

<p>Structure fields can be of the following types:</p>

<ul>
<li><code>u8</code> (or <code>uint8_t</code>)</li>
<li><code>u16</code> (or <code>uint16_t</code>)</li>
<li><code>u32</code> (or <code>uint32_t</code>)</li>
<li><code>u64</code> (or <code>uint64_t</code>)</li>
<li><code>i8</code> (or <code>int8_t</code>)</li>
<li><code>i16</code> (or <code>int16_t</code>)</li>
<li><code>i32</code> (or <code>int32_t</code>)</li>
<li><code>i64</code> (or <code>int64_t</code>)</li>
<li><code>f32</code> (or <code>float</code>)</li>
<li><code>f64</code> (or <code>double</code>)</li>
<li><code>boolean</code></li>
<li><code>string</code></li>
<li><code>file</code></li>
<li><code>tuid</code></li>
<li><code>json</code></li>
<li>Any previously declared select, bitfield or structure</li>
</ul>

<p>Fields can also be arrays of any of these types by just adding <code>[]</code> right after the type name. These arrays cannot take default values, and can grow as needed at runtime. Adding a <code>[ x ]</code>, where <code>x</code> is an integer expression, makes the array fixed and up to <code>x</code> default values can be specified for the field. Just like select items and bitfield flags, structure fields can have an author, a description and a label.</p>

<p>To inform the default value of a field, use the <code>value</code> keyword and write any expression inside the parenthesis. The expression must evaluate to a value which fits in the data type of the field.</p>

<h2>Examples</h2>

<code><pre><span class="keyword">struct</span> Position<span class="operator">
{</span>
  f32 m_X<span class="operator">,</span><span class="keyword">     value</span><span class="operator">(</span><span class="int"> 0</span><span class="operator"> )</span><span class="operator">;</span>
  f32 m_Y<span class="operator">,</span><span class="keyword">     value</span><span class="operator">(</span><span class="int"> 0</span><span class="operator"> )</span><span class="operator">;</span>
  f32 m_Angle<span class="operator">,</span><span class="keyword"> value</span><span class="operator">(</span><span class="int"> 0</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword"> description</span><span class="operator">(</span><span class="string">"The direction the player is looking at (degrees)"</span><span class="operator">)</span><span class="operator">;</span><span class="operator">
}</span><span class="keyword">

struct</span> Mariner<span class="operator">,</span><span class="keyword"> author</span><span class="operator">(</span><span class="string"> "Andre de Leiradella"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword"> description</span><span class="operator">(</span><span class="string"> "The player character"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword"> label</span><span class="operator">(</span><span class="string"> "Player"</span><span class="operator"> )</span><span class="operator">
{</span>
  u32        m_Health<span class="operator">,</span><span class="keyword">     value</span><span class="operator">(</span><span class="int"> 100</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword">                              description</span><span class="operator">(</span><span class="string"> "The player's health"</span><span class="operator"> )</span><span class="operator">;</span>
  Weapon     m_Weapon<span class="operator">,</span><span class="keyword">     value</span><span class="operator">(</span> kPistol<span class="operator"> )</span><span class="operator">,</span><span class="keyword">                          description</span><span class="operator">(</span><span class="string"> "The player's current weapon"</span><span class="operator"> )</span><span class="operator">;</span>
  Powerup    m_Powerup<span class="operator">,</span><span class="keyword">    value</span><span class="operator">(</span> kBerserk<span class="operator"> )</span><span class="operator">,</span><span class="keyword">                         description</span><span class="operator">(</span><span class="string"> "The player's powerups"</span><span class="operator"> )</span><span class="operator">;</span>
  i32<span class="operator">[</span><span class="int"> 8</span><span class="operator"> ]</span>   m_Ammunition<span class="operator">,</span><span class="keyword"> value</span><span class="operator">(</span><span class="operator"> {</span><span class="int"> 0</span><span class="operator">,</span><span class="int"> 0</span><span class="operator">,</span><span class="int"> 20</span><span class="operator">,</span><span class="operator"> -</span><span class="int">1</span><span class="operator">,</span><span class="operator"> -</span><span class="int">1</span><span class="operator">,</span><span class="operator"> -</span><span class="int">1</span><span class="operator">,</span><span class="operator"> -</span><span class="int">1</span><span class="operator">,</span><span class="operator"> -</span><span class="int">1</span><span class="operator"> }</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword"> description</span><span class="operator">(</span><span class="string"> "The ammunition of each weapon, -1 means the player doesn't have it"</span><span class="operator"> )</span><span class="operator">;</span>
  string     m_Name<span class="operator">,</span><span class="keyword">       value</span><span class="operator">(</span><span class="string"> "Mariner"</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword">                        description</span><span class="operator">(</span><span class="string"> "The player's name for multiplayer sessions"</span><span class="operator"> )</span><span class="operator">;</span>
  Position   m_Position<span class="operator">,</span><span class="keyword">   value</span><span class="operator">(</span><span class="operator"> {</span> m_X<span class="operator"> =</span><span class="int"> 100</span><span class="operator">,</span> m_Y<span class="operator"> =</span><span class="int"> 120</span><span class="operator"> }</span><span class="operator"> )</span><span class="operator">,</span><span class="keyword">         description</span><span class="operator">(</span><span class="string"> "The player's position"</span><span class="operator"> )</span><span class="operator">;</span>
  Position<span class="operator">[</span><span class="operator">]</span> m_Deaths<span class="operator">,</span><span class="keyword">                                                description</span><span class="operator">(</span><span class="string"> "Places the player has died in"</span><span class="operator"> )</span><span class="operator">;</span><span class="operator">
}</span></pre></code>

<p>Array values must be written inside braces with commas separating each expression. Values of structured fields, like <code>m_Position</code> above, must also appear inside braces. It's not mandatory that all fields are present in the value.</p>

<hr/><h1><a name="Expressions">Expressions</a></h1>

<p>DDL expressions are very similar to C expressions, and care has been taken to implement the same operators with the same precedence order. The operators, in decreasing order of precedence, are:</p>

<ul>
<li><code>?</code> (ternary operator)</li>
<li><code>||</code> (logic or)</li>
<li><code>&&</code> (logic and)</li>
<li><code>|</code> (arithmetic or)</li>
<li><code>^</code> (arithmetic xor)</li>
<li><code>&</code> (arithmetic and)</li>
<li><code>==</code> and <code>!=</code> (equality)</li>
<li><code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> and <code>&gt;=</code> (comparison)</li>
<li><code>&lt;&lt;</code> and <code>&gt;&gt;</code> (shift)</li>
<li><code>+</code> and <code>-</code> (add and subtract)</li>
<li><code>*</code>, <code>/</code> and <code>%</code> (multiply, divide and modulus)</li>
<li><code>+</code>, <code>-</code>, <code>~</code> and <code>!</code> (unary positive, negative, complement and logic not)</li>
</ul>

<p>Terminals can be binary, octal, decimal and hexadecimal integer constants, floating point constants, string literals, the <code>true</code> and <code>false</code> constants, <code>pi</code>, the natural number <code>e</code>, and expressions between parenthesis.</p>

<p>Binary constants are written similarly to hexadecimal constants but using the <code>0b</code> prefix instead of <code>0x</code>. String literals are specified inside single or double quotes, and any occurrence of <code>%xx</code> in the string is substituted by the character with hexadecimal value <code>xx</code>.</p>

<p>The constants <code>true</code> and <code>false</code> evaluates to the integers 1 and 0 respectively.</p>

<hr/><h1><a name="Comments">Comments</a></h1>

<p>DDL files can have C and C++ style comments:</p>

<ul>
<li><code>/* this is a comment */</code></li>
<li><code>// this is a comment that ends at the end of the line</code></li>
</ul>

<hr/><h1><a name="DDL API">DDL API</a></h1>

<p>The <a href="#DDL API">DDL API</a> are a collection of functions and structures that allows for DDL source code compilation and subsequent querying of the components found in the source file for i.e. code generation.</p>

<h2>Common methods</h2>

<p>Many structures present a set of common methods that are explained here.</p>

<a name="GetName">GetName</a>

<p>Returns the name of the component, i.e. a select's name or a structure's field's name.</p>

<a name="GetAuthor">GetAuthor</a>

<p>If the component has been tagged with the <code>author</code> tag, <code><a href="#GetAuthor">GetAuthor</a></code> returns the contents of the tag, otherwise it returns <code>NULL</code>. This tag can be used to document the person who authored the component.</p>

<a name="GetDescription">GetDescription</a>

<p>If the component has been tagged with the <code>description</code> tag, <code><a href="#GetDescription">GetDescription</a></code> returns the contents of the tag, otherwise it returns <code>NULL</code>. This tag can be used to give the component a verbose description.</p>

<a name="GetLabel">GetLabel</a>

<p>If the component has been tagged with the <code>label</code> tag, <code><a href="#GetLabel">GetLabel</a></code> returns the contents of the tag, otherwise it returns <code>NULL</code>. This tag can be used to give the component a label to be used in the user interface, for example.</p>

<a name="GetDisplayLabel">GetDisplayLabel</a>

<p>Returns the contents of the <code>label</code> tag if it has been defined and is not the empty string. Otherwise it returns the name of the component.</p>

<a name="GetNameHash">GetNameHash</a>

<p>Returns the hash of the components's name. The hash is created with <a href="#DDLParser::StringCrc32"><code>DDLParser::StringCrc32</code></a>.</p>

<a name="GetTags">GetTags</a>

<p>Returns the first tag defined for the component, or <code>NULL</code> if the component has no tags defined.</h2>

<a name="GetTag">GetTag</a>

<p>Finds and returns a tag by its type. Alternatively, type can be the hash of the generic tag to be searched for. Either way, if the tag isn't found <code>NULL</code> is returned.</p>

<hr/><h1><a name="DDLParser::Compile"><code>DDLParser::Compile</code></a></h1>

<p><code><a href="#DDLParser::Definition">DDLParser::Definition</a>* <a href="#DDLParser::Compile">DDLParser::Compile</a>( DDLParser::LinearAllocator* definition, DDLParser::LinearAllocator* scratch, const void* source, size_t source_size, char* error, size_t error_size, bool two_us_reserved, int bitfield_limit )</code></p>

<p>The <a href="#DDLParser::Compile"><code>DDLParser::Compile</code></a> function compiles a DDL source file into a <a href="#DDLParser::Definition"><code>DDLParser::Definition</code></a> ready to be used to generate code.</p>

<h2>Parameters</h2>

<ul>
<li><code>definition</code>: A <code>DDLParser::LinearAllocator</code> where the definition is assembled. When <a href="#DDLParser::Compile"><code>DDLParser::Compile</code></a> returns, this allocator will have the complete definition.</li>
<li><code>scratch</code>: A <code>DDLParser::LinearAllocator</code> used for temporary work. Can be discarded after <a href="#DDLParser::Compile"><code>DDLParser::Compile</code></a> returns.</li>
<li><code>source</code>: A pointer to the DDL source code. This buffer doesn't have to be null-terminated and cannot be <code>NULL</code>.</li>
<li><code>source_size</code>: The size of the <code>source</code> buffer.</li>
<li><code>error</code>: A pointer to a buffer where the error message, if there's one, will be written to. Cannot be <code>NULL</code>.</li>
<li><code>error_size</code>: The size of the <code>error</code> buffer.</li>
<li><code>two_us_reserved</code>: If true, identifiers starting with two underlines are reserved and disallowed in the source code.</li>
<li><code>bitfield_limit</code>: The maximum number of flags allowed in a bitfield. If this value is zero, there is no limit on the number of flags per bitfield.</li>
</ul>

<h2>Return value</h2>

<p>If the parse succeeds it returns the definition assembled in <code>definition</code> casted to a <a href="#DDLParser::Definition"><code>DDLParser::Definition</code></a> pointer. If there was an error, <a href="#DDLParser::Compile"><code>DDLParser::Compile</code></a> returns <code>NULL</code> and <code>error</code> is filled with the error message.</p>

<hr/><h1><a name="DDLParser::StringCrc32"><code>DDLParser::StringCrc32</code></a></h1>

<p><code>uint32_t <a href="#DDLParser::StringCrc32">DDLParser::StringCrc32</a>( const char* data )</code></p>

<p>Returns the CRC32 of the string.</p>

<hr/><h1><a name="DDLParser::Definition"><code>DDLParser::Definition</code></a></h1>

<p>After a successful parsing, <a href="#DDLParser::Compile"><code>DDLParser::Compile</code></a> returns a <a href="#DDLParser::Definition"><code>DDLParser::Definition</code></a>, which is used as the starting point to query all selects, bitfields, and structures, defined in the source code.</p>

<p><a href="#DDLParser::Definition"><code>DDLParser::Definition</code></a> has the following methods:</p>

<a name="DDLParser::Definition::GetNumAggregates"><code>DDLParser::Definition::GetNumAggregates</code></a>

<p>Returns the number of aggregates (selects, bitfields and structures) in the definition.</p>

<a name="DDLParser::Definition::GetTotalSize"><code>DDLParser::Definition::GetTotalSize</code></a>

<p>Returns the total size in bytes of the definition. This can be used if you want to write it into a file for example.</p>

<a name="DDLParser::Definition::FromBinRep"><code>DDLParser::Definition::FromBinRep</code></a>

<p>Just returns the <code>bin_rep</code> pointer casted to a <a href="#DDLParser::Definition"><code>DDLParser::Definition</code></a>.</p>

<a name="DDLParser::Definition::GetAggregate"><code>DDLParser::Definition::GetAggregate</code></a>

<p>Returns an aggregate given its index. Aggregates are saved into the definition in the order they appear in the source code. No bounds check is done with <code>index</code>.</p>

<a name="DDLParser::Definition::FindAggregate"><code>DDLParser::Definition::FindAggregate</code></a>

<p>Finds and returns an aggregate by name. If the aggregate does not exist, <code>NULL</code> is returned.</p>

<a name="DDLParser::Definition::FindAggregate/hash"><code>DDLParser::Definition::FindAggregate</code>/hash</a>

<p>Finds and returns an aggregate by the hash of its name. If the aggregate does not exist, <code>NULL</code> is returned. The hash must be created with <a href="#DDLParser::StringCrc32"><code>DDLParser::StringCrc32</code></a>.</p>

<hr/><h1><a name="DDLParser::Aggregate"><code>DDLParser::Aggregate</code></a></h1>

<p>An aggregate holds information common to selects, bitfields, and structures. It has the following common methods: <code><a href="#GetName">GetName</a></code>, <code><a href="#GetAuthor">GetAuthor</a></code>, <code><a href="#GetDescription">GetDescription</a></code>, <code><a href="#GetLabel">GetLabel</a></code>, <code><a href="#GetDisplayLabel">GetDisplayLabel</a></code>, and <code><a href="#GetNameHash">GetNameHash</a></code>.</p>

<a name="DDLParser::Aggregate::GetType"><code>DDLParser::Aggregate::GetType</code></a>

<p>Returns the type of the aggregate, <code>DDLParser::kSelect</code>, <code>DDLParser::kBitfield</code>, or <code>DDLParser::kStruct</code>.</p>

<a name="DDLParser::Aggregate::ToSelect"><code>DDLParser::Aggregate::ToSelect</code></a>

<p>Returns the aggregate casted to <a href="#DDLParser::Select"><code>DDLParser::Select</code></a> without checking for the actual aggregate type.</p>

<a name="DDLParser::Aggregate::ToBitfield"><code>DDLParser::Aggregate::ToBitfield</code></a>

<p>Returns the aggregate casted to <a href="#DDLParser::Bitfield"><code>DDLParser::Bitfield</code></a> without checking for the actual aggregate type.</p>

<a name="DDLParser::Aggregate::ToStruct"><code>DDLParser::Aggregate::ToStruct</code></a>

<p>Returns the aggregate casted to <a href="#DDLParser::Struct"><code>DDLParser::Struct</code></a> without checking for the actual aggregate type.</p>

<hr/><h1><a name="DDLParser::Select"><code>DDLParser::Select</code></a></h1>

<p>A select is like a C enum, but you can't define the value of the items. Their value is always the hash code of their identifiers. A select holds information about its items.</p>

<p>In addition to the methods listed here, selects have the following common methods: <code><a href="#GetName">GetName</a></code>, <code><a href="#GetAuthor">GetAuthor</a></code>, <code><a href="#GetDescription">GetDescription</a></code>, <code><a href="#GetLabel">GetLabel</a></code>, <code><a href="#GetDisplayLabel">GetDisplayLabel</a></code>, <code><a href="#GetNameHash">GetNameHash</a></code>, <code><a href="#GetTags">GetTags</a></code>, and <code><a href="#GetTag">GetTag</a></code>.</p>

<a name="DDLParser::Select::GetNumItems"><code>DDLParser::Select::GetNumItems</code></a>

<p>Returns the number of items contained in the select.</p>

<a name="DDLParser::Select::GetDefaultItem"><code>DDLParser::Select::GetDefaultItem</code></a>

<p>Returns the index of the item defined as the default item for the select. If no item was defined as the default, the default item is the first defined. This can be used to initialize variables to a default value if none is given for example.</p>

<a name="DDLParser::Select::FindItem"><code>DDLParser::Select::FindItem</code></a>

<p>Finds and returns an item by name. If the item does not exist, <code>NULL</code> is returned.</p>

<a name="DDLParser::Select::FindItem/hash"><code>DDLParser::Select::FindItem</code>/hash</a>

<p>Finds and returns an item by the hash of its name. If the item does not exist, <code>NULL</code> is returned. The hash must be created with <a href="#DDLParser::StringCrc32"><code>DDLParser::StringCrc32</code></a>.</p>

<hr/><h1><a name="DDLParser::SelectItem"><code>DDLParser::SelectItem</code></a></h1>

<p>A select item represents an item declared in a select and has the following common methods: <code><a href="#GetName">GetName</a></code>, <code><a href="#GetAuthor">GetAuthor</a></code>, <code><a href="#GetDescription">GetDescription</a></code>, <code><a href="#GetLabel">GetLabel</a></code>, <code><a href="#GetDisplayLabel">GetDisplayLabel</a></code>, <code><a href="#GetNameHash">GetNameHash</a></code>, <code><a href="#GetTags">GetTags</a></code>, and <code><a href="#GetTag">GetTag</a></code>.</p>

<p>Select items doesn't have any particular method besides the common ones listed above.</p>

<hr/><h1><a name="DDLParser::Bitfield"><code>DDLParser::Bitfield</code></a></h1>

<p>A bitfield is a set, and bitfield flags are the set's items. Unlike select items, a bitfield flag has a value associated to it. This value can be an explicit zero, an unique, automatically assigned value or a set which is the union of other flags. If the value is automatically assigned, it starts with one and is incremented for each assignment.</p>

<p>In addition to the methods listed here, bitfields have the following common methods: <code><a href="#GetName">GetName</a></code>, <code><a href="#GetAuthor">GetAuthor</a></code>, <code><a href="#GetDescription">GetDescription</a></code>, <code><a href="#GetLabel">GetLabel</a></code>, <code><a href="#GetDisplayLabel">GetDisplayLabel</a></code>, <code><a href="#GetNameHash">GetNameHash</a></code>, <code><a href="#GetTags">GetTags</a></code>, and <code><a href="#GetTag">GetTag</a></code>.</p>

<a name="DDLParser::Bitfield::GetNumFlags"><code>DDLParser::Bitfield::GetNumFlags</code></a>

<p>Returns the number of flags contained in the bitfield.</p>

<a name="DDLParser::Bitfield::GetDefaultFlag"><code>DDLParser::Bitfield::GetDefaultFlag</code></a>

<p>Returns the index of the flag defined as the default flag for the bitfield. If no flag was defined as the default, the default item is the empty flag. If an empty flag wasn't declared, The first flag is elected the default. This can be used to initialize variables to a default value if none is given for example.</p>

<a name="DDLParser::Bitfield::FindFlag"><code>DDLParser::Bitfield::FindFlag</code></a>

<p>Finds and returns a flag by name. If the flag does not exist, <code>NULL</code> is returned.</p>

<a name="DDLParser::Bitfield::FindFlag/hash"><code>DDLParser::Bitfield::FindFlag</code>/hash</a>

<p>Finds and returns a flag by the hash of its name. If the flag does not exist, <code>NULL</code> is returned. The hash must be created with <a href="#DDLParser::StringCrc32"><code>DDLParser::StringCrc32</code></a>.</p>

<hr/><h1><a name="DDLParser::BitfieldFlag"><code>DDLParser::BitfieldFlag</code></a></h1>

<p>A flag is a unique element in a set, or a set of other flags. A flag has the following common methods: <code><a href="#GetName">GetName</a></code>, <code><a href="#GetAuthor">GetAuthor</a></code>, <code><a href="#GetDescription">GetDescription</a></code>, <code><a href="#GetLabel">GetLabel</a></code>, <code><a href="#GetDisplayLabel">GetDisplayLabel</a></code>, <code><a href="#GetNameHash">GetNameHash</a></code>, <code><a href="#GetTags">GetTags</a></code>, and <code><a href="#GetTag">GetTag</a></code>.</p>

<p>Flags also have the following unique methods:</p>

<a name="DDLParser::BitfieldFlag::GetValue"><code>DDLParser::BitfieldFlag::GetValue</code></a>

<p>Returns the value of the flag in case it's the empty flag or a set. If neither is true, this function returns <code>NULL</code>.</p>

<a name="DDLParser::BitfieldFlag::GetBit"><code>DDLParser::BitfieldFlag::GetBit</code></a>

<p>If the flag is the empty flag, or if it's a set, this functions returns zero. Otherwise, it returns an automatically assigned value for the flag which is unique in the bitfield. This values starts at one and is incremented for each flag that uses it. It can be used to generate code for flags as bits in an integer, i.e. <code>1 &lt;&lt; ( flag->GetBit() - 1 )</code>.</p>

<hr/><h1><a name="DDLParser::BitfieldFlagValue"><code>DDLParser::BitfieldFlagValue</code></a></h1>

<p>Defines the value of a flag when it's either the empty flag or a set.</p>

<a name="DDLParser::BitfieldFlagValue::GetCount"><code>DDLParser::BitfieldFlagValue::GetCount</code></a>

<p>If the flag is the empty flag, this function returns zero. Otherwise, it returns the number of flags contained in the flag.</p>

<a name="DDLParser::BitfieldFlagValue::GetFlagIndex"><code>DDLParser::BitfieldFlagValue::GetFlagIndex</code></a>

<p>Returns the index of the flag which is part of this set.</p>

<h2>Bitfield example</h2>

<p>As an example, this code generates C++ code that outputs a bitfield's flags as bits in an unsigned integer:</p>

<code><pre><span class="keyword">static</span><span class="type"> void</span> GenerateBitfield<span class="operator">(</span> DDLParser<span class="operator">:</span><span class="operator">:</span>Bitfield<span class="operator">*</span> bf<span class="operator"> )</span><span class="operator">
{</span>
  printf<span class="operator">(</span><span class="string"> "namespace %s\n"</span><span class="operator">,</span> bf<span class="operator">-</span><span class="operator">></span><a href="#GetName">GetName</a><span class="operator">(</span><span class="operator">)</span><span class="operator"> )</span><span class="operator">;</span>
  printf<span class="operator">(</span><span class="string"> "{\n"</span><span class="operator"> )</span><span class="operator">;</span><span class="flow">

  for</span><span class="operator"> (</span><span class="type"> uint32_t</span> i<span class="operator"> =</span><span class="int"> 0</span><span class="operator">;</span> i<span class="operator"> <</span> bf<span class="operator">-</span><span class="operator">></span>GetNumFlags<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span> i<span class="operator">+</span><span class="operator">+</span><span class="operator"> )</span><span class="operator">
  {</span>
    DDLParser<span class="operator">:</span><span class="operator">:</span>BitfieldFlag<span class="operator">*</span> flag<span class="operator"> =</span> bf<span class="operator">-</span><span class="operator">></span>GetFlag<span class="operator">(</span> i<span class="operator"> )</span><span class="operator">;</span>
    DDLParser<span class="operator">:</span><span class="operator">:</span>BitfieldFlagValue<span class="operator">*</span> val<span class="operator"> =</span> flag<span class="operator">-</span><span class="operator">></span>GetValue<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span>

    printf<span class="operator">(</span><span class="string"> "  static const uint32_t %-20s = "</span><span class="operator">,</span> flag<span class="operator">-</span><span class="operator">></span><a href="#GetName">GetName</a><span class="operator">(</span><span class="operator">)</span><span class="operator"> )</span><span class="operator">;</span><span class="flow">

    if</span><span class="operator"> (</span> val<span class="operator"> =</span><span class="operator">=</span> NULL<span class="operator"> )</span><span class="operator">
    {</span><span class="comment">
      // The flag has an automatically assigned value.</span>
      printf<span class="operator">(</span><span class="string"> "0x%08x;\n"</span><span class="operator">,</span><span class="int"> 1</span><span class="operator"> <</span><span class="operator"><</span><span class="operator"> (</span> flag<span class="operator">-</span><span class="operator">></span>GetBit<span class="operator">(</span><span class="operator">)</span><span class="operator"> -</span><span class="int"> 1</span><span class="operator"> )</span><span class="operator"> )</span><span class="operator">;</span><span class="operator">
    }</span><span class="flow">
    else</span><span class="operator">
    {</span><span class="flow">
      if</span><span class="operator"> (</span> val<span class="operator">-</span><span class="operator">></span>GetCount<span class="operator">(</span><span class="operator">)</span><span class="operator"> =</span><span class="operator">=</span><span class="int"> 0</span><span class="operator"> )</span><span class="operator">
      {</span><span class="comment">
        // The flag is the empty flag.</span>
        printf<span class="operator">(</span><span class="string"> "0x%08x;\n"</span><span class="operator">,</span><span class="int"> 0</span><span class="operator"> )</span><span class="operator">;</span><span class="operator">
      }</span><span class="flow">
      else</span><span class="operator">
      {</span><span class="comment">
        // The flag is a set containing other flags.</span>
        DDLParser<span class="operator">:</span><span class="operator">:</span>BitfieldFlag<span class="operator">*</span> other<span class="operator"> =</span> bf<span class="operator">-</span><span class="operator">></span>GetFlag<span class="operator">(</span><span class="int"> 0</span><span class="operator"> )</span><span class="operator">;</span>
        printf<span class="operator">(</span><span class="string"> "%s"</span><span class="operator">,</span> other<span class="operator">-</span><span class="operator">></span><a href="#GetName">GetName</a><span class="operator">(</span><span class="operator">)</span><span class="operator"> )</span><span class="operator">;</span><span class="flow">

        for</span><span class="operator"> (</span><span class="type"> uint32_t</span> j<span class="operator"> =</span><span class="int"> 1</span><span class="operator">;</span> j<span class="operator"> <</span> val<span class="operator">-</span><span class="operator">></span>GetCount<span class="operator">(</span><span class="operator">)</span><span class="operator">;</span> j<span class="operator">+</span><span class="operator">+</span><span class="operator"> )</span><span class="operator">
        {</span>
          other<span class="operator"> =</span> bf<span class="operator">-</span><span class="operator">></span>GetFlag<span class="operator">(</span> val<span class="operator">-</span><span class="operator">></span>GetFlagIndex<span class="operator">(</span> j<span class="operator"> )</span><span class="operator"> )</span><span class="operator">;</span>
          printf<span class="operator">(</span><span class="string"> " | %s"</span><span class="operator">,</span> other<span class="operator">-</span><span class="operator">></span><a href="#GetName">GetName</a><span class="operator">(</span><span class="operator">)</span><span class="operator"> )</span><span class="operator">;</span><span class="operator">
        }</span>

        printf<span class="operator">(</span><span class="string"> ";\n"</span><span class="operator"> )</span><span class="operator">;</span><span class="operator">
      }</span><span class="operator">
    }</span><span class="operator">
  }</span>

  printf<span class="operator">(</span><span class="string"> "}\n"</span><span class="operator"> )</span><span class="operator">;</span><span class="operator">
}</span></pre></code>

<hr/><h1><a name="DDLParser::Struct"><code>DDLParser::Struct</code></a></h1>

<p><a href="#Structures">Structures</a> are collections of fields. Each field has its own type, which can be a native type, a select, a bitfield, another structure, a fixed or dynamic array of the previous types, or a hashmap mapping an integer, a string, a file, or a tuid to any other type.</p>

<p>In addition to the methods listed here, structures have the following common methods: <code><a href="#GetName">GetName</a></code>, <code><a href="#GetAuthor">GetAuthor</a></code>, <code><a href="#GetDescription">GetDescription</a></code>, <code><a href="#GetLabel">GetLabel</a></code>, <code><a href="#GetDisplayLabel">GetDisplayLabel</a></code>, <code><a href="#GetNameHash">GetNameHash</a></code>, <code><a href="#GetTags">GetTags</a></code>, and <code><a href="#GetTag">GetTag</a></code>.</p>

<a name="DDLParser::Struct::GetNumFields"><code>DDLParser::Struct::GetNumFields</code></a>

<p>Returns the number of fields contained in the structure.</p>

<a name="DDLParser::Struct::GetParent"><code>DDLParser::Struct::GetParent</code></a>

<p>Returns the parent structure of this structure. If the structure doesn't inherit from another structure, it returns <code>NULL</code>.</p>

<a name="DDLParser::Struct::GetDefinition"><code>DDLParser::Struct::GetDefinition</code></a>

<p>Returns the definition where the structure was defined.</p>

<a name="DDLParser::Struct::FindField"><code>DDLParser::Struct::FindField</code></a>

<p>Finds and returns a field by name. If the field does not exist, <code>NULL</code> is returned.</p>

<a name="DDLParser::Struct::FindField/hash"><code>DDLParser::Struct::FindField</code>/hash</a>

<p>Finds and returns a field by the hash of its name. If the field does not exist, <code>NULL</code> is returned. The hash must be created with <a href="#DDLParser::StringCrc32"><code>DDLParser::StringCrc32</code></a>.</p>

<a name="DDLParser::Struct::IsInherited"><code>DDLParser::Struct::IsInherited</code></a>

<p>Returns <code>true</code> if the field is from a parent structure.</p>

<a name="DDLParser::Struct::GetSchemaCrc"><code>DDLParser::Struct::GetSchemaCrc</code></a>

<p>The schema crc reflects the type, count, name, and order of each field. If any of those change, then the crc changes. It does not reflect default values or any tags.</p>

<hr/><h1><a name="DDLParser::StructField"><code>DDLParser::StructField</code></a></h1>

<p>A field is an instance of a given type. A field has these common methods: <code><a href="#GetName">GetName</a></code>, <code><a href="#GetAuthor">GetAuthor</a></code>, <code><a href="#GetDescription">GetDescription</a></code>, <code><a href="#GetLabel">GetLabel</a></code>, <code><a href="#GetDisplayLabel">GetDisplayLabel</a></code>, <code><a href="#GetNameHash">GetNameHash</a></code>, <code><a href="#GetTags">GetTags</a></code>, and <code><a href="#GetTag">GetTag</a></code>.</p>

<p>Fields also have the following unique method.</p>

<a name="DDLParser::StructField::GetValueInfo"><code>DDLParser::StructField::GetValueInfo</code></a>

<p>Returns the value information of the field. A field always have a <a href="#DDLParser::StructField::GetValueInfo"><code>DDLParser::StructField::GetValueInfo</code></a> so this method never returns <code>NULL</code>.</p>

<hr/><h1><a name="DDLParser::StructValueInfo"><code>DDLParser::StructValueInfo</code></a></h1>

<p>A <a href="#DDLParser::StructValueInfo"><code>DDLParser::StructValueInfo</code></a> holds information for both a field declared in a structure and its default values if the field has a structure for its type. It has the the <code><a href="#GetTags">GetTags</a></code> and <code><a href="#GetTag">GetTag</a></code> common methods.</p>

<a name="DDLParser::StructValueInfo::GetNameHash"><code>DDLParser::StructValueInfo::GetNameHash</code></a>

<p>Returns the hash of the field's name.</p>

<a name="DDLParser::StructValueInfo::GetType"><code>DDLParser::StructValueInfo::GetType</code></a>

<p>Returns the type of the field which is a value from the <code>DDLParser::Type</code> enumeration.</p>

<a name="DDLParser::StructValueInfo::GetTypeNameHash"><code>DDLParser::StructValueInfo::GetTypeNameHash</code></a>

<p>Returns the hash of the field's type name. Only usefull if the field has a select, bitfield or structure type so it's possible to query the definition for the actual aggregate.</p>

<a name="DDLParser::StructValueInfo::GetTypeName"><code>DDLParser::StructValueInfo::GetTypeName</code></a>

<p>Deprecated.</p>

<a name="DDLParser::StructValueInfo::GetArrayType"><code>DDLParser::StructValueInfo::GetArrayType</code></a>

<p>Returns the array type of the field. Possible values are <code>DDLParser::kScalar</code> (the field is not an array), <code>DDLParser::kFixed</code> (the field is an array with a fixed dimension), <code>DDLParser::kDynamic</code> (the field is an array without an specified dimention) and <code>DDLParser::kHashmap</code> (the field is a hashmap), from the <code>DDLParser::ArrayType</code> enumeration.</p>

<a name="DDLParser::StructValueInfo::GetValue"><code>DDLParser::StructValueInfo::GetValue</code></a>

<p>Returns the array of default values for the field. If the field hasn't a default value, it returns <code>NULL</code>. Only scalar and fixed array types of fields can have a default value. In the former, only the first position of the array of values is valid. In the later, the array of values is valid from 0 to <a href="#DDLParser::StructValueInfo::GetCount"><code>DDLParser::StructValueInfo::GetCount</code></a>.</p>

<a name="DDLParser::StructValueInfo::GetCount"><code>DDLParser::StructValueInfo::GetCount</code></a>

<p>Returns the size of the array if the array is fixed. Always returns one for scalars and zero for dynamic arrays and hashmaps.</p>

<a name="DDLParser::StructValueInfo::GetKeyType"><code>DDLParser::StructValueInfo::GetKeyType</code></a>

<p>Returns the DDL type of a hashmap key. If the field is not a hashmap, this method doesn't return anything meaningful.</p>

<a name="DDLParser::StructValueInfo::GetKeyBitSize"><code>DDLParser::StructValueInfo::GetKeyBitSize</code></a>

<p>Convenience method that returns the bit size of the hashmap key. Returns 64 for <code>DDLParser::kInt64</code>, <code>DDLParser::kUint64</code>, <code>DDLParser::kFloat64</code>, and <code>DDLParser::kTuid</code>, and 32 for all other types.</p>

<a name="DDLParser::StructValueInfo::AllowSubStruct"><code>DDLParser::StructValueInfo::AllowSubStruct</code></a>

<p>Convenience method that returns <code>true</code> if the field was tagged with the <code>tag( AllowSubstruct )</code> generic tag.</p>

<a name="DDLParser::StructValueInfo::GetSchemaCrc"><code>DDLParser::StructValueInfo::GetSchemaCrc</code></a>

<p>The schema crc reflects the type, count, and name of the field. If any of those change, then the crc changes. It does not reflect default values or any tags.</p>

<a name="DDLParser::StructValueInfo::GetAggregate"><code>DDLParser::StructValueInfo::GetAggregate</code></a>

<p>Returns the aggregate which is the type of the field. If the field has not a select, bitfield or structure as its type, this method returns <code>NULL</code>.</p>

<hr/><h1><a name="DDLParser::StructFieldValue"><code>DDLParser::StructFieldValue</code></a></h1>

<p><a href="#DDLParser::StructFieldValue"><code>DDLParser::StructFieldValue</code></a> is an union which holds the values defined for fields.</p>

<code><pre><span class="keyword">union</span> DDLParser<span class="operator">:</span><span class="operator">:</span>StructFieldValue<span class="operator">
{</span><span class="type">
  uint8_t</span>                m_Uint8<span class="operator">[</span><span class="int"> 0</span><span class="operator"> ]</span><span class="operator">;</span><span class="type">
  uint16_t</span>               m_Uint16<span class="operator">[</span><span class="int"> 0</span><span class="operator"> ]</span><span class="operator">;</span><span class="type">
  uint32_t</span>               m_Uint32<span class="operator">[</span><span class="int"> 0</span><span class="operator"> ]</span><span class="operator">;</span><span class="type">
  uint64_t</span>               m_Uint64<span class="operator">[</span><span class="int"> 0</span><span class="operator"> ]</span><span class="operator">;</span><span class="type">
  int8_t</span>                 m_Int8<span class="operator">[</span><span class="int"> 0</span><span class="operator"> ]</span><span class="operator">;</span><span class="type">
  int16_t</span>                m_Int16<span class="operator">[</span><span class="int"> 0</span><span class="operator"> ]</span><span class="operator">;</span><span class="type">
  int32_t</span>                m_Int32<span class="operator">[</span><span class="int"> 0</span><span class="operator"> ]</span><span class="operator">;</span><span class="type">
  int64_t</span>                m_Int64<span class="operator">[</span><span class="int"> 0</span><span class="operator"> ]</span><span class="operator">;</span><span class="type">
  float</span>                  m_Float32<span class="operator">[</span><span class="int"> 0</span><span class="operator"> ]</span><span class="operator">;</span><span class="type">
  double</span>                 m_Float64<span class="operator">[</span><span class="int"> 0</span><span class="operator"> ]</span><span class="operator">;</span>
  String                 m_String<span class="operator">[</span><span class="int"> 0</span><span class="operator"> ]</span><span class="operator">;</span><span class="type">
  uint32_t</span>               m_Select<span class="operator">[</span><span class="int"> 0</span><span class="operator"> ]</span><span class="operator">;</span>
  StructBitfieldValuePtr m_Bitfield<span class="operator">[</span><span class="int"> 0</span><span class="operator"> ]</span><span class="operator">;</span>
  StructStructValuePtr   m_Struct<span class="operator">[</span><span class="int"> 0</span><span class="operator"> ]</span><span class="operator">;</span>
  StructUnknownValuePtr  m_Unknown<span class="operator">[</span><span class="int"> 0</span><span class="operator"> ]</span><span class="operator">;</span><span class="comment"> // Deprecated</span><span class="type">
  uint8_t</span>                m_Boolean<span class="operator">[</span><span class="int"> 0</span><span class="operator"> ]</span><span class="operator">;</span>
  String                 m_File<span class="operator">[</span><span class="int"> 0</span><span class="operator"> ]</span><span class="operator">;</span><span class="type">
  uint64_t</span>               m_Tuid<span class="operator">[</span><span class="int"> 0</span><span class="operator"> ]</span><span class="operator">;</span>
  String                 m_Json<span class="operator">[</span><span class="int"> 0</span><span class="operator"> ]</span><span class="operator">;</span><span class="operator">
}</span></pre></code>

<p>When a field's <a href="#DDLParser::StructValueInfo"><code>DDLParser::StructValueInfo</code></a> has a pointer to a <a href="#DDLParser::StructFieldValue"><code>DDLParser::StructFieldValue</code></a> (via <a href="#DDLParser::StructValueInfo::GetValue"><code>DDLParser::StructValueInfo::GetValue</code></a>), it means the field has default values. The member of the union that is to be accessed depends on <a href="#DDLParser::StructValueInfo::GetType"><code>DDLParser::StructValueInfo::GetType</code></a>, and how many entries are valid depends on the field's array type. For <code>DDLParser::kScalar</code> fields, one position only is valid. For <code>DDLParser::kFixed</code> fields, positions from zero to <a href="#DDLParser::StructValueInfo::GetCount"><code>DDLParser::StructValueInfo::GetCount</code></a><code> - 1</code> are valid. <code>DDLParser::kDynamic</code> and <code>DDLParser::kHashmap</code> fields don't have default values.</p>

<hr/><h1><a name="DDLParser::StructBitfieldValue"><code>DDLParser::StructBitfieldValue</code></a></h1>

<p>When a field is of a bitfield type and has a default value, this value is held in the <code>m_Bitfield</code> member of the <a href="#DDLParser::StructFieldValue"><code>DDLParser::StructFieldValue</code></a> union. It has the following methods:</p>

<h2><a name="DDLParser::StructBitfieldValue::GetCount"><code>DDLParser::StructBitfieldValue::GetCount</code></a></h2>

<p>Returns the number of flags that make the default value of the field.</p>

<h2><a name="DDLParser::StructBitfieldValue::GetHash"><code>DDLParser::StructBitfieldValue::GetHash</code></a></h2>

<p>Returns the hash of the flag at the given index. This hash can be used to get the actual flag from the bitfield via <a href="#DDLParser::Bitfield::FindFlag"><code>DDLParser::Bitfield::FindFlag</code></a>.</p>

<hr/><h1><a name="DDLParser::StructStructValue"><code>DDLParser::StructStructValue</code></a></h1>

<p>When a field is of a structure type and has a default value, it's default value is held in the <code>m_Struct</code> member of the <a href="#DDLParser::StructFieldValue"><code>DDLParser::StructFieldValue</code></a> union. For each field receiving a default value, <a href="#DDLParser::StructStructValue"><code>DDLParser::StructStructValue</code></a> has a <a href="#DDLParser::StructValueInfo"><code>DDLParser::StructValueInfo</code></a> with details of which field is being initialized and what value it's receiving.</p>

<p><a href="#DDLParser::StructStructValue"><code>DDLParser::StructStructValue</code></a> has the following methods:</p>

<h2><a name="DDLParser::StructStructValue::GetCount"><code>DDLParser::StructStructValue::GetCount</code></a></h2>

<p>Returns the number of value infos in this structure value.</p>

<h2><a name="DDLParser::StructStructValue::GetValueInfo"><code>DDLParser::StructStructValue::GetValueInfo</code></a></h2>

<p>Returns the value info at the given index.</p>

<h1>Example</h1>

<code><pre><span class="keyword">struct</span> A<span class="operator">
{</span><span class="type">
  uint32_t</span> a<span class="operator">,</span><span class="keyword"> value</span><span class="operator">(</span><span class="int"> 1</span><span class="operator"> )</span><span class="operator">;</span><span class="type">
  uint32_t</span> b<span class="operator">;</span><span class="operator">
}</span><span class="keyword">

struct</span> B<span class="operator">
{</span><span class="type">
  uint32_t</span><span class="operator">[</span><span class="int"> 2</span><span class="operator"> ]</span> c<span class="operator">,</span><span class="keyword"> value</span><span class="operator">(</span><span class="operator"> {</span><span class="int"> 1</span><span class="operator">,</span><span class="int"> 2</span><span class="operator"> }</span><span class="operator"> )</span><span class="operator">;</span><span class="type">
  uint32_t</span><span class="operator">[</span><span class="operator">]</span> d<span class="operator">;</span>
  string<span class="operator">{</span><span class="type"> uint32_t</span><span class="operator"> }</span> f<span class="operator">;</span>
  A g<span class="operator">,</span><span class="keyword"> value</span><span class="operator">(</span><span class="operator"> {</span> a<span class="operator"> =</span><span class="int"> 2</span><span class="operator"> }</span><span class="operator"> )</span><span class="operator">;</span><span class="operator">
}</span></pre></code>

<p>The <a href="#DDLParser::StructValueInfo"><code>DDLParser::StructValueInfo</code></a> for the fields declared in the DDL code above are:</p>

<p><table border="1" width="80%" cellspacing="0" cellpadding="3">
<tr><th colspan="3" bgcolor="#e0e0e0"><code>A.a</code></th></tr>
<tr><th width="15%">Method</th><th width="10%">Return Value</th><th width="55%">Meaning</th></tr>
<tr><td><a href="#GetNameHash">GetNameHash</a>()</td><td align="right">0x0136c985</td><td><a href="#DDLParser::StringCrc32"><code>DDLParser::StringCrc32</code></a> of "a", the field name.</td></tr>
<tr><td>GetType()</td><td align="right">2</td><td><code>DDLParser::kUint32</code>.</td></tr>
<tr><td>GetTypeNameHash()</td><td align="right">0x0d5d2ca7</td><td><a href="#DDLParser::StringCrc32"><code>DDLParser::StringCrc32</code></a> of "uint32_t", but meaningless.</td></tr>
<tr><td>GetArrayType()</td><td align="right">0</td><td><code>DDLParser::kScalar</code>.</td></tr>
<tr><td>GetValue()</td><td align="right">0x009d0074</td><td>The address of the <a href="#DDLParser::StructFieldValue"><code>DDLParser::StructFieldValue</code></a>, since this field has a default value defined for it. This <a href="#DDLParser::StructFieldValue"><code>DDLParser::StructFieldValue</code></a> has the value 1 at <code>m_Uint32[ 0 ]</code>.</td></tr>
<tr><td><a href="#GetTags">GetTags</a>()</td><td align="right">0x00000000</td><td><code>NULL</code> since this field doesn't have any tag.</td></tr>
<tr><td>GetKeyType()</td><td align="right">0</td><td>Meaningless.</td></tr>
<tr><td>GetKeyBitSize()</td><td align="right">32</td><td>Meaningless.</td></tr>
<tr><td>GetAggregate()</td><td align="right">0x00000000</td><td><code>NULL</code> since this field has a scalar type.</td></tr>
<tr><td>GetCount()</td><td align="right">1</td><td>This field holds one <code>uint32_t</code> value.</td></tr>
</table></p>

<p><table border="1" width="80%" cellspacing="0" cellpadding="3">
<tr><th colspan="3" bgcolor="#e0e0e0"><code>A.b</code></th></tr>
<tr><th width="15%">Method</th><th width="10%">Return Value</th><th width="55%">Meaning</th></tr>
<tr><td><a href="#GetNameHash">GetNameHash</a>()</td><td align="right">0x983f983f</td><td><a href="#DDLParser::StringCrc32"><code>DDLParser::StringCrc32</code></a> of "a", the field name.</td></tr>
<tr><td>GetType()</td><td align="right">2</td><td><code>DDLParser::kUint32</code>.</td></tr>
<tr><td>GetTypeNameHash()</td><td align="right">0x0d5d2ca7</td><td><a href="#DDLParser::StringCrc32"><code>DDLParser::StringCrc32</code></a> of "uint32_t", but meaningless.</td></tr>
<tr><td>GetArrayType()</td><td align="right">0</td><td><code>DDLParser::kScalar</code>.</td></tr>
<tr><td>GetValue()</td><td align="right">0x00000000</td><td><code>NULL</code> since this field hasn't a default value defined for it.</td></tr>
<tr><td><a href="#GetTags">GetTags</a>()</td><td align="right">0x00000000</td><td><code>NULL</code> since this field doesn't have any tag.</td></tr>
<tr><td>GetKeyType()</td><td align="right">0</td><td>Meaningless.</td></tr>
<tr><td>GetKeyBitSize()</td><td align="right">32</td><td>Meaningless.</td></tr>
<tr><td>GetAggregate()</td><td align="right">0x00000000</td><td><code>NULL</code> since this field has a scalar type.</td></tr>
<tr><td>GetCount()</td><td align="right">1</td><td>This field holds one <code>uint32_t</code> value.</td></tr>
</table></p>

<p><table border="1" width="80%" cellspacing="0" cellpadding="3">
<tr><th colspan="3" bgcolor="#e0e0e0"><code>B.c</code></th></tr>
<tr><th width="15%">Method</th><th width="10%">Return Value</th><th width="55%">Meaning</th></tr>
<tr><td><a href="#GetNameHash">GetNameHash</a>()</td><td align="right">0xef38a8a9</td><td><a href="#DDLParser::StringCrc32"><code>DDLParser::StringCrc32</code></a> of "c", the field name.</td></tr>
<tr><td>GetType()</td><td align="right">2</td><td><code>DDLParser::kUint32</code>.</td></tr>
<tr><td>GetTypeNameHash()</td><td align="right">0x0d5d2ca7</td><td><a href="#DDLParser::StringCrc32"><code>DDLParser::StringCrc32</code></a> of "uint32_t", but meaningless.</td></tr>
<tr><td>GetArrayType()</td><td align="right">1</td><td><code>DDLParser::kFixed</code>.</td></tr>
<tr><td>GetValue()</td><td align="right">0x00780128</td><td>The address of the <a href="#DDLParser::StructFieldValue"><code>DDLParser::StructFieldValue</code></a>, since this field has a default value defined for it. This <a href="#DDLParser::StructFieldValue"><code>DDLParser::StructFieldValue</code></a> has the values 1 and 2 at <code>m_Uint32[ 0 ]</code> and <code>m_Uint32[ 1 ]</code>.</td></tr>
<tr><td><a href="#GetTags">GetTags</a>()</td><td align="right">0x00000000</td><td><code>NULL</code> since this field doesn't have any tag.</td></tr>
<tr><td>GetKeyType()</td><td align="right">0</td><td>Meaningless.</td></tr>
<tr><td>GetKeyBitSize()</td><td align="right">32</td><td>Meaningless.</td></tr>
<tr><td>GetAggregate()</td><td align="right">0x00000000</td><td><code>NULL</code> since this field has a scalar type.</td></tr>
<tr><td>GetCount()</td><td align="right">2</td><td>This field holds two <code>uint32_t</code> values.</td></tr>
</table></p>

<p><table border="1" width="80%" cellspacing="0" cellpadding="3">
<tr><th colspan="3" bgcolor="#e0e0e0"><code>B.d</code></th></tr>
<tr><th width="15%">Method</th><th width="10%">Return Value</th><th width="55%">Meaning</th></tr>
<tr><td><a href="#GetNameHash">GetNameHash</a>()</td><td align="right">0x715c3d0a</td><td><a href="#DDLParser::StringCrc32"><code>DDLParser::StringCrc32</code></a> of "d", the field name.</td></tr>
<tr><td>GetType()</td><td align="right">2</td><td><code>DDLParser::kUint32</code>.</td></tr>
<tr><td>GetTypeNameHash()</td><td align="right">0x0d5d2ca7</td><td><a href="#DDLParser::StringCrc32"><code>DDLParser::StringCrc32</code></a> of "uint32_t", but meaningless.</td></tr>
<tr><td>GetArrayType()</td><td align="right">2</td><td><code>DDLParser::kDynamic</code>.</td></tr>
<tr><td>GetValue()</td><td align="right">0x00000000</td><td><code>NULL</code> since this field hasn't (and can't have) a default value defined for it.</td></tr>
<tr><td><a href="#GetTags">GetTags</a>()</td><td align="right">0x00000000</td><td><code>NULL</code> since this field doesn't have any tag.</td></tr>
<tr><td>GetKeyType()</td><td align="right">0</td><td>Meaningless.</td></tr>
<tr><td>GetKeyBitSize()</td><td align="right">32</td><td>Meaningless.</td></tr>
<tr><td>GetAggregate()</td><td align="right">0x00000000</td><td><code>NULL</code> since this field has a scalar type.</td></tr>
<tr><td>GetCount()</td><td align="right">0</td><td>This field is a dynamic array, which initialy has no elements.</td></tr>
</table></p>

<p><table border="1" width="80%" cellspacing="0" cellpadding="3">
<tr><th colspan="3" bgcolor="#e0e0e0"><code>B.f</code></th></tr>
<tr><th width="15%">Method</th><th width="10%">Return Value</th><th width="55%">Meaning</th></tr>
<tr><td><a href="#GetNameHash">GetNameHash</a>()</td><td align="right">0x9f525c26</td><td><a href="#DDLParser::StringCrc32"><code>DDLParser::StringCrc32</code></a> of "f", the field name.</td></tr>
<tr><td>GetType()</td><td align="right">10</td><td><code>DDLParser::kString</code>.</td></tr>
<tr><td>GetTypeNameHash()</td><td align="right">0xa76af9f8</td><td><a href="#DDLParser::StringCrc32"><code>DDLParser::StringCrc32</code></a> of "string", but meaningless.</td></tr>
<tr><td>GetArrayType()</td><td align="right">3</td><td><code>DDLParser::kHashmap</code>.</td></tr>
<tr><td>GetValue()</td><td align="right">0x00000000</td><td><code>NULL</code> since this field hasn't (and can't have) a default value defined for it.</td></tr>
<tr><td><a href="#GetTags">GetTags</a>()</td><td align="right">0x00000000</td><td><code>NULL</code> since this field doesn't have any tag.</td></tr>
<tr><td>GetKeyType()</td><td align="right">2</td><td><code>DDLParser::kUint32</code>.</td></tr>
<tr><td>GetKeyBitSize()</td><td align="right">32</td><td>The size of the key of this hashmap, in bits.</td></tr>
<tr><td>GetAggregate()</td><td align="right">0x00000000</td><td><code>NULL</code> since this field has a scalar type (strings are scalars in DDL).</td></tr>
<tr><td>GetCount()</td><td align="right">0</td><td>This field is a hashmap, which initialy has no elements.</td></tr>
</table></p>

<p><table border="1" width="80%" cellspacing="0" cellpadding="3">
<tr><th colspan="3" bgcolor="#e0e0e0"><code>B.g</code></th></tr>
<tr><th width="15%">Method</th><th width="10%">Return Value</th><th width="55%">Meaning</th></tr>
<tr><td><a href="#GetNameHash">GetNameHash</a>()</td><td align="right">0xe8556cb0</td><td><a href="#DDLParser::StringCrc32"><code>DDLParser::StringCrc32</code></a> of "g", the field name.</td></tr>
<tr><td>GetType()</td><td align="right">13</td><td><code>DDLParser::kStruct</code>.</td></tr>
<tr><td>GetTypeNameHash()</td><td align="right">0x3a58e94d</td><td><a href="#DDLParser::StringCrc32"><code>DDLParser::StringCrc32</code></a> of "A", the name of the aggregate which is the type of this field.</td></tr>
<tr><td>GetArrayType()</td><td align="right">0</td><td><code>DDLParser::kScalar</code>.</td></tr>
<tr><td>GetValue()</td><td align="right">0x007801e4</td><td>The address of the <a href="#DDLParser::StructFieldValue"><code>DDLParser::StructFieldValue</code></a>, since this field has a default value defined for it. This <a href="#DDLParser::StructFieldValue"><code>DDLParser::StructFieldValue</code></a> has a <a href="#DDLParser::StructStructValue"><code>DDLParser::StructStructValue</code></a> pointer at <code>m_Struct[ 0 ]</code>.</td></tr>
<tr><td><a href="#GetTags">GetTags</a>()</td><td align="right">0x00000000</td><td><code>NULL</code> since this field doesn't have any tag.</td></tr>
<tr><td>GetKeyType()</td><td align="right">0</td><td>Meaningless.</td></tr>
<tr><td>GetKeyBitSize()</td><td align="right">32</td><td>Meaningless.</td></tr>
<tr><td>GetAggregate()</td><td align="right">0x00780014</td><td>The address of <a href="#DDLParser::Struct"><code>DDLParser::Struct</code></a> <code>A</code> which is the type of this field.</td></tr>
<tr><td>GetCount()</td><td align="right">1</td><td>This field holds one structure <code>A</code> value.</td></tr>
</table></p>

<p>The details of the <a href="#DDLParser::StructStructValue"><code>DDLParser::StructStructValue</code></a> for <code>B.g</code> are:</p>

<p><table border="1" width="80%" cellspacing="0" cellpadding="3">
<tr><th colspan="3" bgcolor="#e0e0e0">Details of the <a href="#DDLParser::StructStructValue"><code>DDLParser::StructStructValue</code></a> for <code>B.g</code></th></tr>
<tr><th width="15%">Method</th><th width="10%">Return Value</th><th width="55%">Meaning</th></tr>
<tr><td><a href="#GetNameHash">GetNameHash</a>()</td><td align="right">0x0136c985</td><td><a href="#DDLParser::StringCrc32"><code>DDLParser::StringCrc32</code></a> of "a", the name of the field being initialized.</td></tr>
<tr><td>GetType()</td><td align="right">2</td><td><code>DDLParser::kUint32</code>.</td></tr>
<tr><td>GetTypeNameHash()</td><td align="right">0x0d5d2ca7</td><td><a href="#DDLParser::StringCrc32"><code>DDLParser::StringCrc32</code></a> of "uint32_t", but meaningless.</td></tr>
<tr><td>GetArrayType()</td><td align="right">0</td><td><code>DDLParser::kScalar</code>.</td></tr>
<tr><td>GetValue()</td><td align="right">0x00780214</td><td>The address of the <a href="#DDLParser::StructFieldValue"><code>DDLParser::StructFieldValue</code></a>, since this field has a default value defined for it. This <a href="#DDLParser::StructFieldValue"><code>DDLParser::StructFieldValue</code></a> has the value 2 at m_Uint32[ 0 ], which overrides the default value 1 of <code>A.a</code>.</td></tr>
<tr><td><a href="#GetTags">GetTags</a>()</td><td align="right">0x00000000</td><td><code>NULL</code> as value infos of fields being initialized can't have tags.</td></tr>
<tr><td>GetKeyType()</td><td align="right">0</td><td>Meaningless.</td></tr>
<tr><td>GetKeyBitSize()</td><td align="right">32</td><td>Meaningless.</td></tr>
<tr><td>GetAggregate()</td><td align="right">0x00000000</td><td><code>NULL</code> since this field has a scalar type.</td></tr>
<tr><td>GetCount()</td><td align="right">1</td><td>This field holds one <code>uint32_t</code> value.</td></tr>
</table></p>

<hr/><h1><a name="DDLParser::Tag"><code>DDLParser::Tag</code></a></h1>

<p>Tags are decorations that can be added to structures, fields, selects, items, bitfields, and flags. Their purpose is to pass down information to code generators to change the way code is generated for them.</p>

<p><a href="#DDLParser::Tag"><code>DDLParser::Tag</code></a> is the parent of all other tags, and has the following methods:</p>

<a name="DDLParser::Tag::GetType"><code>DDLParser::Tag::GetType</code></a>

<p>Returns the type of the tag, which is a value from the <code>DDLParser::TagType</code> enum.</p>

<a name="DDLParser::Tag::GetNext"><code>DDLParser::Tag::GetNext</code></a>

<p>The tags of a DDL component form a linked list. <code><a href="#GetTags">GetTags</a></code> returns the first tag for the component, and <a href="#DDLParser::Tag::GetNext"><code>DDLParser::Tag::GetNext</code></a> is used to return the next tag in the linked list. Returns <code>NULL</code> at the end of the list.</p>

<hr/><h1><a name="DDLParser::GenericTag"><code>DDLParser::GenericTag</code></a></h1>

<p>All tag types are deprecated, new code should only use generic tags that can be defined without changing the DDL parser. Generic tags have the <code>DDLParser::kGeneric</code> type and the following methods in addition to the methods from <a href="#DDLParser::Tag"><code>DDLParser::Tag</code></a>:</p>

<a name="DDLParser::GenericTag::GetName"><code>DDLParser::GenericTag::GetName</code></a>

<p>Returns the identifier used in the tag definition.</p>

<a name="DDLParser::GenericTag::GetNameHash"><code>DDLParser::GenericTag::GetNameHash</code></a>

<p>Returns the hash of the identifier used in the tag definition, created with <a href="#DDLParser::StringCrc32"><code>DDLParser::StringCrc32</code></a>.</p>

<a name="DDLParser::GenericTag::GetNumValues"><code>DDLParser::GenericTag::GetNumValues</code></a>

<p>Returns the number of values defined in the tag after its name.</p>

<a name="DDLParser::GenericTag::operator%[%]"><code>DDLParser::GenericTag::operator</code>%[%]</a>

<p>Returns the value defined for the tag at the given index.</p>

<hr/><h1><a name="DDLParser::GenericTagValue"><code>DDLParser::GenericTagValue</code></a></h1>

<p>Represents a value defined in a generic tag after its name:</p>

<code><pre><span class="keyword">struct</span> DDLParser<span class="operator">:</span><span class="operator">:</span>GenericTagValue<span class="operator">
{</span><span class="type">
  uint32_t</span> m_Type<span class="operator">;</span><span class="keyword">

  union</span><span class="operator">
  {</span><span class="type">
    int64_t</span> m_Int64<span class="operator">;</span><span class="type">
    double</span>  m_Float64<span class="operator">;</span>
    String  m_String<span class="operator">;</span><span class="operator">
  }</span><span class="operator">;</span><span class="operator">
}</span></pre></code>

<p>The <code>m_Type</code> member can be <code>DDLParser::kInt64</code>, <code>DDLParser::kFloat64</code>, or <code>DDLParser::kString</code>. Use this member to know the type of the value and which of the other members to access in a value.</p>

<hr/><h1><a name="Validating Generic Tags">Validating Generic Tags</a></h1>

<p>Every time the parser parses a generic tag it calls one of the following callback functions to validate the tag:</p>

<ul>
<li><code>typedef bool DDLParser::CheckStructTag( <a href="#DDLParser::Definition">DDLParser::Definition</a>* def, <a href="#DDLParser::Struct">DDLParser::Struct</a>* structure, <a href="#DDLParser::GenericTag">DDLParser::GenericTag</a>* tag, <a href="#DDLParser::Str">DDLParser::Str</a>* tag_name, <a href="#DDLParser::TagSet">DDLParser::TagSet</a>* tag_set, char* error, size_t error_size );</code></li>
<li><code>typedef bool DDLParser::CheckFieldTag( <a href="#DDLParser::Definition">DDLParser::Definition</a>* def, <a href="#DDLParser::Struct">DDLParser::Struct</a>* structure, <a href="#DDLParser::StructField">DDLParser::StructField</a>* field, <a href="#DDLParser::GenericTag">DDLParser::GenericTag</a>* tag, <a href="#DDLParser::Str">DDLParser::Str</a>* tag_name, <a href="#DDLParser::TagSet">DDLParser::TagSet</a>* tag_set, char* error, size_t error_size );</code></li>
<li><code>typedef bool DDLParser::CheckSelectTag( <a href="#DDLParser::Definition">DDLParser::Definition</a>* def, <a href="#DDLParser::Select">DDLParser::Select</a>* select, <a href="#DDLParser::GenericTag">DDLParser::GenericTag</a>* tag, <a href="#DDLParser::Str">DDLParser::Str</a>* tag_name, <a href="#DDLParser::TagSet">DDLParser::TagSet</a>* tag_set, char* error, size_t error_size );</code></li>
<li><code>typedef bool DDLParser::CheckItemTag( <a href="#DDLParser::Definition">DDLParser::Definition</a>* def, <a href="#DDLParser::Select">DDLParser::Select</a>* select, <a href="#DDLParser::SelectItem">DDLParser::SelectItem</a>* item, <a href="#DDLParser::GenericTag">DDLParser::GenericTag</a>* tag, <a href="#DDLParser::Str">DDLParser::Str</a>* tag_name, <a href="#DDLParser::TagSet">DDLParser::TagSet</a>* tag_set, char* error, size_t error_size );</code></li>
<li><code>typedef bool DDLParser::CheckBitfieldTag( <a href="#DDLParser::Definition">DDLParser::Definition</a>* def, <a href="#DDLParser::Bitfield">DDLParser::Bitfield</a>* bitfield, <a href="#DDLParser::GenericTag">DDLParser::GenericTag</a>* tag, <a href="#DDLParser::Str">DDLParser::Str</a>* tag_name, <a href="#DDLParser::TagSet">DDLParser::TagSet</a>* tag_set, char* error, size_t error_size );</code></li>
<li><code>typedef bool DDLParser::CheckFlagTag( <a href="#DDLParser::Definition">DDLParser::Definition</a>* def, <a href="#DDLParser::Bitfield">DDLParser::Bitfield</a>* bitfield, <a href="#DDLParser::BitfieldFlag">DDLParser::BitfieldFlag</a>* flag, <a href="#DDLParser::GenericTag">DDLParser::GenericTag</a>* tag, <a href="#DDLParser::Str">DDLParser::Str</a>* tag_name, <a href="#DDLParser::TagSet">DDLParser::TagSet</a>* tag_set, char* error, size_t error_size );</code></li>
</ul>

<p>These callbacks must return <code>true</code> to inform the parser that the tag was accepted, or <code>false</code> to inform that it was rejected. In the later case, the callback must also fill the <code>error</code> buffer with an error message up to <code>error_size</code> characters.</p>

<p>If a callback isn't defined, the tag is automatically accepted.</p>

<a name="DDLParser::Str"><code>DDLParser::Str</code></a>

<p><a href="#DDLParser::Str"><code>DDLParser::Str</code></a> represent internal strings during the parsing. They point directly into the DDL source code being parsed so they cannot be changed. The methods that can be used to validate a generic tag are:</p>

<ul>
<li><code>bool <a href="#DDLParser::Str">DDLParser::Str</a>::operator==( const <a href="#DDLParser::Str">DDLParser::Str</a>::Str& other ) const</code></li>
<li><code>bool <a href="#DDLParser::Str">DDLParser::Str</a>::operator==( const char* other ) const</code></li>
<li><code>const char* <a href="#DDLParser::Str">DDLParser::Str</a>::GetChars() const</code></li>
<li><code>unsigned int <a href="#DDLParser::Str">DDLParser::Str</a>::GetLength() const</code></li>
<li><code>uint32_t <a href="#DDLParser::Str">DDLParser::Str</a>::GetHash() const</code></li>
</ul>

<a name="DDLParser::TagSet"><code>DDLParser::TagSet</code></a>

<p>When one of the callbacks is called to validate a generic tag, a <a href="#DDLParser::TagSet"><code>DDLParser::TagSet</code></a> is provided to allow for keeping a record of which tags have already been defined and i.e. disallow duplicates. The methods that can be used during validation are:</p>

<ul>
<li><code>bool <a href="#DDLParser::TagSet">DDLParser::TagSet</a>::Insert( uint32_t element )</code></li>
<li><code>bool <a href="#DDLParser::TagSet">DDLParser::TagSet</a>::Exists( uint32_t element )</code></li>
</ul>

<p>Note that the tag's name hash (as returned by <a href="#DDLParser::GenericTag::GetNameHash"><code>DDLParser::GenericTag::GetNameHash</code></a>) should be used with tag sets.</p>

<h2>Note</h2>

<p><a href="#DDLParser::Compile"><code>DDLParser::Compile</code></a> doesn't give the programmer the chance to install callbacks in the parser. For that, duplicate the source code of <a href="#DDLParser::Compile"><code>DDLParser::Compile</code></a> and add the callbacks as needed.</p>

<hr/><h1><a name="DDL Grammar">DDL Grammar</a></h1>

<p>The language permits the declaration of any number of structures, bitfields and selects. At least one such declaration must exist in a valid DDL file.</p>

<code><pre>grammar ddl;

ddl
  : ( typedef | struct | bitfield | select )+
  ;</pre></code>

<p>A typedef is an alias to a data type, array type and a set of tags. After defining a typedef it can be used to declare fields, which will have everything that was defined in the typedef.</p>

<code><pre>typedef
  : 'typedef' data_type ( '[' ( expression )? ']' | '{' data_type '}' )? ( ',' typedef_info )*
  ;

typedef_info
  : 'author' '(' LITERAL ')'
  | 'description' '(' LITERAL ')'
  | 'label' '(' LITERAL ')'
  | 'uirender' '(' LITERAL ')'
  | 'callback' '(' LITERAL ')'
  | 'key' '(' LITERAL ')'
  | 'units' '(' LITERAL ')'
  | 'extensions' '(' LITERAL ( ',' LITERAL )* ')'
  | 'vaulthints' '(' LITERAL ( ',' LITERAL )* ')'
  | 'uirange' '(' expression ',' expression ( ',' expression ',' expression ( ',' expression )? )? ')'
  | generic_tag
  ;</pre></code>

<p>A structure begins with the <code>struct</code> keyword and with the structure name, an identifier. After the name the author, description, and label of the structure can be specified but they're not mandatory. The fields can then be specified enclosed by curly braces.</p>

<code><pre>struct
  : 'struct' ID ( ',' struct_info )* '{' field* '}'
  ;</pre></code>

<p><code>struct_info</code> allows for additional information about aggregates, namely its author, description and label. Labels are used to name UI controls, and descriptions can be used as tips for these controls. Although the grammar allows for repetitions, the parser checks for duplicates and errors accordingly.</p>

<p>The structure can also inherit fields from a parent structure, specified by the <code>base</code> tag.</p>

<code><pre>struct_info
  : 'author' '(' LITERAL ')'
  | 'description' '(' LITERAL ')'
  | 'label' '(' LITERAL ')'
  | 'base' '(' ID ')'
  | 'uirender' '(' LITERAL ')'
  | 'version' '(' LITERAL ')'
  | 'callback' '(' LITERAL ')'
  | 'key' '(' LITERAL ')'
  | generic_tag
  ;

generic_tag:
  : 'tag' '(' ID ( ',' expression )* ')'
  ;</pre></code>

<p>A field declaration begins with the field type of a typedef identifier. After that the field name (an identifier), is parsed and additional information about the field can be specified.</p>

<code><pre>field
  : ( field_type | ID ) ID ( ',' field_info )* ';'
  ;</pre></code>

<p>The field type is a data type. If the data type is followed by a opening square brace, it denotes that the field is an array. If an integer expression is provided within the braces the array has a fixed size, otherwise the array is dynamic and elements can added to/removed from it at runtime (depending on the code that is generated). If the data type is followed by opening curly brace, it denotes a hashmap mapping values of the data type inside the curly braces to values of the data type of the field.</p>

<code><pre>field_type
  : data_type ( '[' ( expression )? ']' | '{' data_type '}' )?
  ;</pre></code>

<p>The field data type can be one of the native types or a custom type. The native types are signed and unsigned integers with 8, 16, 32 or 64 bits, float, double, string, file, boolean, tuid and json. A custom type is just an identifier denoting a select, bitfield or structure.</p>

<code><pre>data_type
  : 'uint8_t'  | 'u8'
  | 'uint16_t' | 'u16'
  | 'uint32_t' | 'u32'
  | 'uint64_t' | 'u64'
  | 'int8_t'   | 'i8'
  | 'int16_t'  | 'i16'
  | 'int32_t'  | 'i32'
  | 'int64_t'  | 'i64'
  | 'float'    | 'f32'
  | 'double'   | 'f64'
  | 'boolean'  | 'bool'
  | 'string'
  | 'file'
  | 'tuid'
  | 'json'
  | ID
  ;</pre></code>

<p><code>field_info</code> allows for additional information about fields, namely its author, description, label and a default value. The default value is the value used to initialize the field.</p>

<code><pre>field_info
  : 'author' '(' LITERAL ')'
  | 'description' '(' LITERAL ')'
  | 'label' '(' LITERAL ')'
  | 'value' '(' default_value ')'
  | 'extensions' '(' LITERAL ( ',' LITERAL )* ')'
  | 'vaulthints' '(' LITERAL ( ',' LITERAL )* ')'
  | 'uirange' '(' expression ',' expression ( ',' expression ',' expression ( ',' expression )? )? ')'
  | 'uirender' '(' LITERAL ')'
  | 'parallel' '(' ID ')'
  | 'units' '(' LITERAL ')'
  | generic_tag
  ;</pre></code>

<p>The <code>default_value</code> is a complex rule, and which option is taken depends on the context. In other words, it's a parser decision depending on what it was parsing.</p>

<code><pre>default_value
  /* 1 */ : native_value
  /* 2 */ | select_value
  /* 3 */ | bitfield_value
  /* 4 */ | struct_value
  /* 5 */ | '{' native_value   ( ',' native_value   )* '}'
  /* 6 */ | '{' select_value   ( ',' select_value   )* '}'
  /* 7 */ | '{' bitfield_value ( ',' bitfield_value )* '}'
  /* 8 */ | '{' struct_value   ( ',' struct_value   )* '}'
  ;

native_value
  : expression
  ;

select_value
  : ID
  ;

bitfield_value
  : ID ( '|' ID )*
  ;

struct_value
  : '{' ID '=' default_value ( ',' ID '=' default_value )* '}'
  ;</pre></code>

<ul>
<li>Option #1 is taken when the field is of a native type and is not an array.</li>
<li>Option #2 is taken when the field is of a select type and is not an array.</li>
<li>Option #3 is taken when the field is of a bitfield type and is not an array.</li>
<li>Option #4 is taken when the field is of a structure type and is not an array.</li>
<li>Options #5 to #8 correspond to options #1 to #4 but are for arrays of native, select, bitfield and structure values.</li>
</ul>

<p>A bitfield is declared with the <code>bitfield</code> keyword followed by its name, an identifier, which may be followed by additional information. Its flags are declared inside enclosing braces.</p>

<code><pre>bitfield
  : 'bitfield' ID ( ',' bitfield_info )* '{' flag+ '}'
  ;

bitfield_info
  : 'author' '(' LITERAL ')'
  | 'description' '(' LITERAL ')'
  | 'label' '(' LITERAL ')'
  | generic_tag
  ;</pre></code>

<p>Declarations of bitfield flags begin with an identifier which is its name, followed by additional flag information.</p>

<code><pre>flag
  : ID ( ',' flag_info )* ';'
  ;</pre></code>

<p>Besides author, description and label, a flag can be specified as the default flag for the bitfield. Flags can also be declared as empty, meaning that their value is zero. If a value is specified, the flag is a set containing all listed flags.</p>

<code><pre>flag_info
  : 'author' '(' LITERAL ')'
  | 'description' '(' LITERAL ')'
  | 'label' '(' LITERAL ')'
  | 'default'
  | 'value' '(' ID ( '|' ID )* ')'
  | 'empty'
  | generic_tag
  ;</pre></code>

<p>A select is declared in the same way of a bitfield.</p>

<code><pre>select
  : 'select' ID ( ',' select_info )* '{' item+ '}'
  ;

select_info
  : 'author' '(' LITERAL ')'
  | 'description' '(' LITERAL ')'
  | 'label' '(' LITERAL ')'
  | generic_tag
  ;</pre></code>

<p>A select item has an implicit type of <code>uint32_t</code> so it's not possible to define a type for it. Its declaration begin with an identifier which is its name, followed by additional information. The value of a select item is the <a href="#DDLParser::StringCrc32"><code>DDLParser::StringCrc32</code></a> of its name so it's not possible to define a value for it.</p>

<p>The item defined as the default item is used to initialize the default value of structure fields having the select type. As with bitfields, this default can be overridden by using the <code>value</code> tag in the field declaration. If no item is declared as the default, the first item declared in the select will be the default.</p>

<code><pre>item
  : ID ( ',' item_info )* ';'
  ;

item_info
  : 'author' '(' LITERAL ')'
  | 'description' '(' LITERAL ')'
  | 'label' '(' LITERAL ')'
  | 'default'
  | generic_tag
  ;</pre></code>

<p>The expression rule parses any valid C-like expression. It's defined as the ternary operator.</p>

<code><pre>expression
  : ternary
  ;</pre></code>

<p>The ternary operator is a <code>logic_or</code> expression optionally followed by a <code>?</code> and two expressions. If the logic_or expression is true (different from zero), the value of the ternary operator is the result of the first expression. If it's false, the value of the ternary operator is the result of the second expression. If <code>?</code> is not present in the expression, the value of the ternary operator is the value of the <code>logic_or</code> expression.</p>

<code><pre>ternary
  : logic_or ( '?' expression ':' expression )?
  ;</pre></code>

<p>The <code>logic_or</code> expression is the value of a <code>logic_and</code> expression, optionally or'ed with other <code>logic_and</code> expressions.</p>

<code><pre>logic_or
  : logic_and ( '||' logic_and )*
  ;</pre></code>

<p>The <code>logic_and</code> expression is the value of an <code>arithmetic_or</code> expression, optionally and'ed with other <code>arithmetic_or</code> expressions.</p>

<code><pre>logic_and
  : arithmetic_or ( '&&' arithmetic_or )*
  ;</pre></code>

<p>The <code>arithmetic_or</code> expression is the value of an <code>arithmetic_xor</code> expression, optionally bitwise-or'ed with other <code>arithmetic_xor</code> expressions.</p>

<code><pre>arithmetic_or
  : arithmetic_xor ( '|' arithmetic_xor )*
  ;</pre></code>

<p>The <code>arithmetic_xor</code> expression is the value of an <code>arithmetic_and</code> expression, optionally bitwise-xor'ed with other <code>arithmetic_and</code> expressions.</p>

<code><pre>arithmetic_xor
  : arithmetic_and ( '^' arithmetic_and )*
  ;</pre></code>

<p>The <code>arithmetic_and</code> expression is the value of an <code>equal</code> expression, optionally bitwise-and'ed with other <code>equal</code> expressions.</p>

<code><pre>arithmetic_and
  : equal ( '&' equal )*
  ;</pre></code>

<p>The <code>equal</code> expression is the value of a <code>conditional</code> expression, optionally compared for equality or inequality with other <code>conditional</code> expressions. It's thus possible to write <code>a > b == c > d</code> meaning <code>a > b</code> and <code>c > d</code> are both either false or true, and <code>a > b != c > d</code> meaning <code>a > b</code> is true and <code>c > d</code> is false or vice-versa.</p>

<code><pre>equal
  : conditional ( ( '==' | '!=' ) conditional )*
  ;</pre></code>

<p>The <code>conditional</code> expression is the value of a <code>shift</code> expression, optionally compared with other <code>shift</code> expressions with one of the operators <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> or <code>&gt;=</code>.</p>

<code><pre>conditional
  : shift ( ( '<' | '>' | '<=' | '>=' ) shift )*
  ;</pre></code>

<p>The <code>shift</code> expression is the value of a <code>term</code> expression, optionally shifted left or right by other <code>term</code> expressions.</p>

<code><pre>shift
  : term ( ( '<<' | '>>' ) term )*
  ;</pre></code>

<p>The <code>term</code> expression is the value of a <code>factor</code> expression, optionally added to or subtracted from other <code>factor</code> expressions.</p>

<code><pre>term
  : factor ( ( '+' | '-' ) factor )*
  ;</pre></code>

<p>The factor expression is the value of an <code>unary</code> expression, optionally multiplied by, divided by, mod'ed by other <code>unary</code> expressions.</p>

<code><pre>factor
  : unary ( ( '*' | '/' | '%' ) unary )*
  ;</pre></code>

<p>The <code>unary</code> expression is either the value of a <code>terminal</code> or the value of another <code>unary</code> changed by the unary plus, minus, negate or not operators.</p>

<code><pre>unary
  : ( '+' | '-' | '~' | '!' ) unary
  | terminal
  ;</pre></code>

<p>The terminal expression is an octal, hexadecimal, decimal or real (in base 10) number, a string, the constants <code>true</code>, <code>false</code>, <code>pi</code> or <code>e</code>, or another expression enclosed in parenthesis.</p>

<code><pre>terminal
  : OCTAL | BINARY | HEXADECIMAL | DECIMAL | REAL | LITERAL
  | 'true' | 'false'
  | 'pi' | 'e'
  | '(' expression ')'
  ;</pre></code>

<p>Octal constants must begin with a 0, and can only have digits from 0 to 7.</p>

<code><pre>OCTAL
  : '0' ( '0' .. '7' )+
  ;</pre></code>

<p>Binary constants must begin with <code>0b</code>, and can only have digits 0 and 1.</p>

<code><pre>BINARY
  : '0b' ( '0' | '1' )+
  ;</pre></code>

<p>Hexadecimal constants must begin with <code>0x</code>, and can have digits from 0 to 9 and from A to F (case insensitive).</p>

<code><pre>HEXADECIMAL
  : '0x' ( HEX_DIGIT )+
  ;

HEX_DIGIT:
  : '0' .. '9'
  | 'a' .. 'f'
  | 'A' .. 'f'
  ;</pre></code>
  
<p>Decimal numbers can only have digits from 0 to 9. In the lexical analyser, if a number starts with 0 it's considered to be an octal constant.</p>

<code><pre>DECIMAL
  : ( '0' .. '9' )+
  ;</pre></code>

<p>Real numbers are decimal numbers with an optional decimal period followed by another decimal number. They can have an optional exponent (an <code>e</code> or <code>E</code>) followed by the decimal exponent value which can be signed, and optionally ended with an <code>f</code>. If the real number does not have a decimal period and neither an exponent, it must end with an 'f' otherwise it will be analyzed as a decimal number. Note that this is slightly different from what is expected from C.</p>

<code><pre>REAL
  : DECIMAL ( '.' DECIMAL )? ( ( 'e' | 'E' ) ( '+' | '-' ) DECIMAL )? 'f'?
  ;</pre></code>

<p>Identifiers are case sensitive sequences of upper case letters, lower case letters, decimal digits and underscores. They cannot begin with a decimal digit.</p>

<code><pre>ID
  : ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
  ;</pre></code>

<p>Literals are string constants which are sequences of any characters except the percent sign (which is the beginning of an escape sequence), the double quote (which marks the end of the string) and line feed. Strings are enclosed in double quotes.</p>

<code><pre>LITERAL
  : '"' ( '%' HEX_DIGIT HEX_DIGIT | ~( '%' | '"' ) )* '"'
  ;</pre></code>

<p>Escape sequences always start with a <code>%</code>, and must be followed by two hexadecimal digits. These three characters will be converted to one character in the resulting literal, and this character will have the code specified by the two hexadecimal digits.</p>

<p>Literals are codepage agnostic, so the meaning of characters with codes outside of the [0, 127] range are platform dependent.</p>

<hr/><h1>License</h1>

<p>Copyright (c) 2012, Insomniac Games<br/>
All rights reserved.</p>

<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>

<ul>
<li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li>
</ul>

<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>

</body>
</html>
