#include <new>
#include <time.h>

#include <DDLParser.h>

#include "CompilerIf.h"
#include "DefinitionIf.h"

extern "C"
{
  #include "lua.h"
  #include "lualib.h"
  #include "lauxlib.h"
};

int DDLT::Compiler::compile( lua_State* L )
{
  Compiler* self = Check( L, 1 );
  const char* source_name = luaL_checkstring( L, 2 );

  size_t source_size;
  const char* source = luaL_checklstring( L, 3, &source_size );

  char error[ 256 ];

  // 64Mb ought to be enough for anybody.
  LinearAllocator scratch;
  scratch.Init( 64 * 1024 * 1024 );

  DDLParser::Definition* definition = DDLParser::Compile( &self->m_Definition, &scratch, source, source_size, error, sizeof( error ), self->m_TwoUSReserved, self->m_BitfieldLimit );

  scratch.Destroy();

  if ( definition == 0 )
  {
    return luaL_error( L, "%s%s", source_name, error );
  }

  return 0;
}

int DDLT::Compiler::getDefinition( lua_State* L )
{
  Compiler* self = Check( L, 1 );

  DDLParser::Definition* definition = DDLParser::Definition::FromBinRep( (uint8_t*)self->m_Definition.GetBase() );
  return Definition::PushNew( L, definition );
}

int DDLT::Compiler::getDisclaimer( lua_State* L )
{
  Compiler* self = Check( L, 1 );

  char disclaimer[ 256 ];

  time_t build_time = time(NULL);
  tm* build_local_time = localtime( &build_time );

  char build_local_time_string[ 128 ];
  strftime( build_local_time_string, sizeof( build_local_time_string ), "%d %B %Y %H:%M", build_local_time );

  snprintf( disclaimer, sizeof( disclaimer ), "Do not edit. This file generated by %s on %s", self->m_CompilerName, build_local_time_string );
  lua_pushstring( L, disclaimer );
  return 1;
}

int DDLT::Compiler::l__index( lua_State* L )
{
  const char* key  = luaL_checkstring( L, 2 );
  uint32_t    hash = DDLParser::StringCrc32( key );

  switch ( hash )
  {
  case 0xa9cc3c9eU: // compile
    lua_pushcfunction( L, compile );
    return 1;
  case 0xca1e4df3U: // getDefinition
    lua_pushcfunction( L, getDefinition );
    return 1;
  case 0x8a2da777U: // getDisclaimer
    lua_pushcfunction( L, getDisclaimer );
    return 1;
  }

  return 0;
}

int DDLT::Compiler::l__gc( lua_State* L )
{
  Compiler* self = Check( L, 1 );

  self->Destroy();
  return 0;
}

bool DDLT::Compiler::Init( const char* compiler_name, bool two_us_reserved, int bitfield_limit )
{
  m_CompilerName = compiler_name;
  m_TwoUSReserved = two_us_reserved;
  m_BitfieldLimit = bitfield_limit;

  // 64Mb ought to be enough for anybody.
  return m_Definition.Init( 64 * 1024 * 1024 );
}

int DDLT::Compiler::PushNew( lua_State *L, const char* compiler_name, bool two_us_reserved, int bitfield_limit )
{
  Compiler* self = new ( lua_newuserdata( L, sizeof( Compiler ) ) ) Compiler;

  if ( !self->Init( compiler_name, two_us_reserved, bitfield_limit ) )
  {
    return luaL_error( L, "Error creating DDLT::Compiler" );
  }

  if ( luaL_newmetatable( L, "DDT::Compiler" ) )
  {
    lua_pushcfunction( L, l__index );
    lua_setfield( L, -2, "__index" );
    lua_pushcfunction( L, l__gc );
    lua_setfield( L, -2, "__gc" );
  }

  lua_setmetatable( L, -2 );
  return 1;
}

DDLT::Compiler* DDLT::Compiler::Check( lua_State* L, int index )
{
  return (Compiler*)luaL_checkudata( L, index, "DDT::Compiler" );
}
